<?xml-stylesheet href="/rss.xsl" type="text/xsl"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>LIFE CODER</title><link>https://akelio-zhang.github.io/</link><description>Recent content on LIFE CODER</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>2019-2022 Akelio All rights reserved.</copyright><lastBuildDate>Fri, 15 Apr 2022 12:00:00 +0800</lastBuildDate><atom:link href="https://akelio-zhang.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>[2022]读书笔记--用数据讲故事</title><link>https://akelio-zhang.github.io/posts/2022%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AE%B2%E6%95%85%E4%BA%8B/</link><pubDate>Fri, 15 Apr 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AE%B2%E6%95%85%E4%BA%8B/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2022%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AE%B2%E6%95%85%E4%BA%8B/ -&lt;h1 id="读书笔记--用数据讲故事">读书笔记&amp;ndash;用数据讲故事&lt;/h1>
&lt;ul>
&lt;li>第二章 选择有效的图表
&lt;ul>
&lt;li>图表类型
&lt;ul>
&lt;li>简单文本&lt;/li>
&lt;li>表格（不利于展示你的观点）
&lt;ul>
&lt;li>热力图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>点图
&lt;ul>
&lt;li>散点图（往往需要配合辅助线、辅助文本）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>线图
&lt;ul>
&lt;li>折线图（可以增加最大值、最小值的同图展示）&lt;/li>
&lt;li>斜率图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>条形图
&lt;ul>
&lt;li>直方图（竖直条形图）&lt;/li>
&lt;li>堆叠竖直条形图（一般是最下一层能够比较有效对比）&lt;/li>
&lt;li>瀑布图&lt;/li>
&lt;li>水平条形图（适合阅读，分类标签可以很长）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>面积图&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>图表使用建议
&lt;ul>
&lt;li>不要使用饼图&lt;/li>
&lt;li>不要使用3D图&lt;/li>
&lt;li>尽量不要使用双Y轴&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第三章 杂乱是你的敌人&lt;/li>
&lt;li>第四章 聚焦受众的视线（引导到核心的数据）
&lt;ul>
&lt;li>前属性&lt;/li>
&lt;li>颜色&lt;/li>
&lt;li>大小&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>第五章 像设计师一样思考（通过可视化，让读者观众明白你的结论，第四章的升级版）
&lt;ul>
&lt;li>可供性
&lt;ul>
&lt;li>突出重要内容&lt;/li>
&lt;li>消除干扰&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>无障碍
&lt;ul>
&lt;li>不要过于复杂&lt;/li>
&lt;li>擅长使用文字突出结论&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>美观&lt;/li>
&lt;li>接受度&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
- https://akelio-zhang.github.io/posts/2022%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AE%B2%E6%95%85%E4%BA%8B/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>[2022]决策引擎 Note</title><link>https://akelio-zhang.github.io/posts/2022%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E-note/</link><pubDate>Fri, 25 Mar 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E-note/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2022%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E-note/ -&lt;h1 id="2022决策引擎-note">[2022]决策引擎 Note&lt;/h1>
&lt;ul>
&lt;li>开场
&lt;ul>
&lt;li>常见的引擎有哪些？
&lt;ul>
&lt;li>游戏、模板、规则、决策；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>引擎是一套通用的软件解决方案，基于引擎，可以实现一类相似的业务需求；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>决策引擎是什么？
&lt;ul>
&lt;li>如果用最简单的说，对某一类型的事件进行加工处理后得到一个决策结果；&lt;/li>
&lt;li>从这句话看起来，和规则引擎很像，确实很像，或者说决策引擎是一种高级的规则引擎（是基于规则引擎的提升改造以适应更加复杂的流程）；&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>怎么会自己开发出一个决策引擎
&lt;ul>
&lt;li>罗列业务上的诉求&lt;/li>
&lt;li>时间线&lt;/li>
&lt;li>所以一个东西并不是一蹴而就的，也是因为业务的复杂逐渐提升，引擎也在随之提升变化&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>如何设计
&lt;ul>
&lt;li>原则
&lt;ul>
&lt;li>组合&amp;gt;继承&lt;/li>
&lt;li>单一责任&lt;/li>
&lt;li>每一个类应该和尽可能少的类交互，对象的层次设计&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>主要对象
&lt;ul>
&lt;li>Filter&lt;/li>
&lt;li>TaskNode&lt;/li>
&lt;li>Task&lt;/li>
&lt;li>FlowEngine&lt;/li>
&lt;li>IFlowContext&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>效果
&lt;ul>
&lt;li>代码工程可读性、可测试性（可维护性）强；&lt;/li>
&lt;li>不同决策模型均适应&lt;/li>
&lt;li>易扩展
&lt;ul>
&lt;li>方便查问题（日志落表与业务逻辑完全解耦）&lt;/li>
&lt;li>可以在大数据环境运行（不基于Spring）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>应用
&lt;ul>
&lt;li>同业预警财务模型V2&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>未来规划
&lt;ul>
&lt;li>支持并发&lt;/li>
&lt;li>支持节点超时配置&lt;/li>
&lt;li>前端展示转换层，配置与执行流可视化，便于运维&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>启示
&lt;ul>
&lt;li>原型能力
&lt;ul>
&lt;li>从规则引擎&amp;ndash;&amp;gt;规则引擎V2&amp;ndash;&amp;gt;决策引擎&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>产品需要打磨&lt;/li>
&lt;li>其他&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
- https://akelio-zhang.github.io/posts/2022%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E-note/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>LeetCode 刷题指南</title><link>https://akelio-zhang.github.io/posts/2022leetcode-%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</link><pubDate>Fri, 18 Feb 2022 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022leetcode-%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2022leetcode-%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/ -&lt;h1 id="刷题的意义">“刷题”的意义&lt;/h1>
&lt;p>刷题确实可能会让非常多人嗤之以鼻，但是没有办法，这一切都是市场决定的。如果要在这个市场生存，你只有两个选择，适应这条规则或者打破这条规则。如果我们可以打破这条规则，那说明我们拥有更大的价值，这当然很好。但是对于大多数人而言，可能或多或少会得刷一刷题。刷题一方面能让我们面试通过，另一方面也在过程中重温一些基础知识（可以不用再面对繁冗复杂的业务诉求）。&lt;/p>
&lt;h1 id="如何刷">如何刷&lt;/h1>
&lt;p>笔者自己是从两条线分别出发刷题。一，按数据结构类型；二，按算法策略。从这两条线组织刷题顺序可以帮我们更快地构建起题与知识的映射关系。其实在面试解题过程中，关键要解决的就是破除题目本身的外壳，发现本质问题，属于什么类型的问题，需要用怎么样的数据结构与算法来解决。&lt;/p>
&lt;p>现在LeetCode刷题已经非常方便了，并且本身社区也比较活跃。但是，额外的一些参考书籍对于我们的帮助也会非常大。下面罗列两本LeetCode题解。第一本101，是采用C++解题的，这本书的算法写的很容易理解，不像LC社区中很多人追求花哨——一行解题，意义不是很大。在面试过程，清晰的算法过程也是会给面试官比较好的音响。另一本Go写的题解，追求是算法性能，可以给我们拓宽思路，因为一道题解出来现在可能已经不是100分了，最佳的性能会让我们的面试更加突出。&lt;/p>
&lt;h1 id="leetcode-题解参考">LeetCode 题解参考&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>&lt;a href="https://www.changgy.com/leetcode-101">Doing positive things. - LeetCode 101 (changgy.com)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://books.halfrost.com/leetcode/">序 | LeetCode Cookbook (halfrost.com)&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
&lt;h1 id="算法参考书">算法参考书&lt;/h1>
&lt;ol>
&lt;li>
&lt;p>⭐&lt;a href="https://algs4.cs.princeton.edu/home/">Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne (princeton.edu)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a href="https://www.algorist.com/">The Algorithm Design Manual (algorist.com)&lt;/a>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>⭐&lt;a href="https://jeffe.cs.illinois.edu/teaching/algorithms/#book">Algorithms by Jeff Erickson (illinois.edu)&lt;/a>&lt;/p>
&lt;/li>
&lt;/ol>
- https://akelio-zhang.github.io/posts/2022leetcode-%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>[2022]MacBook Pro到手设置</title><link>https://akelio-zhang.github.io/posts/2022macbook-pro%E5%88%B0%E6%89%8B%E8%AE%BE%E7%BD%AE/</link><pubDate>Thu, 10 Feb 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022macbook-pro%E5%88%B0%E6%89%8B%E8%AE%BE%E7%BD%AE/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2022macbook-pro%E5%88%B0%E6%89%8B%E8%AE%BE%E7%BD%AE/ -&lt;h1 id="2022-macbook-pro到手设置">2022-MacBook Pro到手设置&lt;/h1>
&lt;h2 id="效率">效率&lt;/h2>
&lt;ol>
&lt;li>Office 365, Microsoft edge, Onedrive, Todo, Outlook&lt;/li>
&lt;li>Xmind&lt;/li>
&lt;li>Cubox&lt;/li>
&lt;li>Typora&lt;/li>
&lt;li>Sketch&lt;/li>
&lt;/ol>
&lt;h2 id="开发者">开发者&lt;/h2>
&lt;ol>
&lt;li>Homebrew, &lt;a href="https://brew.idayer.com/guide/">https://brew.idayer.com/guide/&lt;/a>
&lt;ol>
&lt;li>Stats&lt;/li>
&lt;li>Alfred&lt;/li>
&lt;li>Item2+ayu&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>VS code
&lt;ol>
&lt;li>extension
&lt;ol>
&lt;li>copilot&lt;/li>
&lt;li>tabnine&lt;/li>
&lt;li>wakatime&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Terminal (item2)
&lt;ol>
&lt;li>&lt;a href="https://wyydsb.xin/Operations/terminal.html#zsh-sh">https://wyydsb.xin/Operations/terminal.html#zsh-sh&lt;/a>&lt;/li>
&lt;li>Zsh-syntax-highlighting&lt;/li>
&lt;li>Zsh-autosuggestions&lt;/li>
&lt;li>Fzf with vim plugin&lt;/li>
&lt;li>vimrc + vim plug&lt;/li>
&lt;li>tabnine by coc.nvim&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Java
&lt;ol>
&lt;li>JetBrains IDEA
&lt;ol>
&lt;li>extensions same as vs code.&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>JDK (&lt;a href="https://www.azul.com/downloads/?os=macos&amp;amp;architecture=arm-64-bit&amp;amp;package=jdk">Java Download | Java 8, Java 11, Java 13 - Linux, Windows &amp;amp; macOS (azul.com)&lt;/a>)&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Go
&lt;ol>
&lt;li>brew install golang&lt;/li>
&lt;li>go proxy setup&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>KX
    1. Clash X Pro: &lt;a href="https://github.com/yichengchen/clashX">https://github.com/yichengchen/clashX&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="娱乐">娱乐&lt;/h2>
&lt;ol>
&lt;li>iina&lt;/li>
&lt;li>wechat&lt;/li>
&lt;/ol>
&lt;h2 id="设置">设置&lt;/h2>
&lt;ol>
&lt;li>Hot corner&lt;/li>
&lt;li>程序坞的大小与缩小&lt;/li>
&lt;li>Apple Watch 解锁&lt;/li>
&lt;li>触控板手势&lt;/li>
&lt;li>iCloud 设置&lt;/li>
&lt;li>桌面使用叠放&lt;/li>
&lt;li>finder 显示状态栏&lt;/li>
&lt;/ol>
&lt;h2 id="远程控制">远程控制&lt;/h2>
&lt;ol>
&lt;li>teamviewer—&amp;gt;todesk—&amp;gt;rustdesk&lt;/li>
&lt;/ol>
&lt;h2 id="参考">参考&lt;/h2>
&lt;ol>
&lt;li>&lt;a href="https://zhuye.notion.site/Macbook-M1-9c908ba2946440aeb02d63609c9990ae">Macbook环境配置（含M1） (notion.site)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://rualc.com/workspace/mac/#brew">Mac 环境（M1 + Monterey） | 前端指南 (rualc.com)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.bilibili.com/video/BV1sD4y1X7MQ">学生党M1 Mac入门指北_哔哩哔哩_bilibili&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.youtube.com/watch?v=67keaaWOKzE">Mac Tutorial for Beginners - Switching from Windows to macOS - YouTube&lt;/a>&lt;/li>
&lt;/ol>
- https://akelio-zhang.github.io/posts/2022macbook-pro%E5%88%B0%E6%89%8B%E8%AE%BE%E7%BD%AE/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>[2021]Notion结束文字工作站的选择纠结</title><link>https://akelio-zhang.github.io/posts/2021notion/</link><pubDate>Thu, 27 Jan 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2021notion/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2021notion/ -&lt;h2 id="0x1-使用过的方案">0x1 使用过的方案&lt;/h2>
&lt;ol>
&lt;li>有道云笔记（markdown支持太弱）&lt;/li>
&lt;li>Microsoft Todo（不太适合大量文字记载）&lt;/li>
&lt;li>语雀（不适合临时想法记录）&lt;/li>
&lt;li>Typora/VS Code + Onedrive（文件之间的关联比较麻烦，没有统一的入口）&lt;/li>
&lt;li>微信公众号（不适合个人内容记载，且使用起来比较麻烦，适合做推广）&lt;/li>
&lt;/ol>
&lt;h2 id="0x2-场景整理">0x2 场景整理&lt;/h2>
&lt;p>问题的解决方案往往要追溯到需求本身，不然只是在为了使用而使用，缺乏了创造力。&lt;/p>
&lt;ol>
&lt;li>工作上对项目、系统的设计、开发、运维的文档落地与持续运维追踪。&lt;/li>
&lt;li>读书笔记记录。&lt;/li>
&lt;li>CS一些技术的学习笔记。&lt;/li>
&lt;li>生活的一些行程安排或记录。&lt;/li>
&lt;li>Todo List。&lt;/li>
&lt;/ol>
&lt;h2 id="0x3-notion最大好处就是all-in-one">0x3 Notion，最大好处就是ALL IN ONE。&lt;/h2>
&lt;ol>
&lt;li>良好的Markdown支持&lt;/li>
&lt;li>UI符合我的审美需求&lt;/li>
&lt;li>能够支持大量文字输入&lt;/li>
&lt;li>因为是web，天生跨平台&lt;/li>
&lt;li>block，database，link的设计，能够满足绝大部分的知识库使用场景（场景2-4）&lt;/li>
&lt;li>支持项目管理，可部分替代teambition（场景1）&lt;/li>
&lt;li>支持Todo，可部分替代todo app（场景5）&lt;/li>
&lt;li>有些遗憾
&lt;ol>
&lt;li>所有数据在线，尽管有了Github的备份和导出，但是没有一套本地持久化的方案总觉得并不安心。&lt;/li>
&lt;li>没有标签系统&lt;/li>
&lt;li>不支持快速的外部文章导入&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="0x4-目前的文字工作方式">0x4 目前的文字工作方式&lt;/h2>
&lt;ol>
&lt;li>
&lt;p>DASHBOARD是所有内容的入口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>DASHBOARD展示的内容尽可能少，一般就是日常要做的、工作追踪、学习提升的三个入口。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Notion主要做有一些计划性的、需要有结果输出的文字工作。&lt;/p>
&lt;ol>
&lt;li>每天使用Github进行备份&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>
&lt;p>[H1]Todo来承载一些紧急类的工作记录（往往重要性不会太强）【可以用便利贴替代】&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[H2]Xmind承担思维脑图，基本无可替代，数据用Onedrive管理。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[H3]备忘录只做个人信息备忘录，待办事项直接用todo/cubox解决。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[IN]cubox承载信息流的记录（手机、PC浏览器），替代之前的微信收藏、知乎收藏。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>[OUT]微信公众号、知乎专栏用来做对外输出。（Notion本身也提供了链接分享，但是有墙，并没有什么x用）&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;del>放弃语雀&lt;/del>，是因为流量还是小了一点。&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;del>Onenote暂时处于停止使用的状态&lt;/del>，主要原因是格式版本比较心累，markdown不好用，跨平台能力有限。但是对于一些图、画较多的场景，Onenote有他自由排版的优势。&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://akelio-zhang.github.io/images/notion-station.webp" alt="文字工作流2022">&lt;/p>
&lt;p>当然，目前在使用Notion还有一些不舒服的地方：1）DASHBOARD呈现的内容过多，会分散注意力；2）Notion中很多已经完成的内容，目前只是简单放在database置为完成状态，或者移入存档Page。这些内容在较长不会做更新，却依旧占据了较多的篇幅，也会分散注意力。目前使用toggle或者database filter来隐藏。&lt;/p>
- https://akelio-zhang.github.io/posts/2021notion/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>About Me</title><link>https://akelio-zhang.github.io/posts/about-me/</link><pubDate>Wed, 26 Jan 2022 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/about-me/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/about-me/ -&lt;p>&lt;strong>Coder &amp;amp; Photographer&lt;/strong>&lt;/p>
&lt;h2 id="我的设备">我的设备&lt;/h2>
&lt;p>[计算设备]&lt;/p>
&lt;ol>
&lt;li>*PC (i7-8700 + 32G + GTX 1066) with Dell 2720Q + Dell 2414H&lt;/li>
&lt;li>*NUC 11 (16G) with Dell 2520DR (workplace)&lt;/li>
&lt;li>*QNAP T453D mini with (512G + 256G + 4T)&lt;/li>
&lt;li>*ThinkPad T460s (i7-6600U + 8G)&lt;/li>
&lt;li>*RaspBerry 3 (for scheduling)&lt;/li>
&lt;/ol>
&lt;p>[配件]&lt;/p>
&lt;ol>
&lt;li>Filco 87 Black&lt;/li>
&lt;li>Anne Pro II (workplace)&lt;/li>
&lt;li>GPW&lt;/li>
&lt;li>G304 (workplace)&lt;/li>
&lt;li>Bose SoundLink Resolve&lt;/li>
&lt;li>BenQ ScreenBar Halo&lt;/li>
&lt;li>Xiaomi ScreenBar (workplace)&lt;/li>
&lt;/ol>
&lt;p>[自动化]&lt;/p>
&lt;ul>
&lt;li>Github: awesome-list&lt;/li>
&lt;li>Github: notion-backup&lt;/li>
&lt;li>Github: blog deploy by hugo when push&lt;/li>
&lt;li>iOS: Apple Watch (wakeup; 9:00; arrive at home)&lt;/li>
&lt;li>iOS: clock switch (by Calendar)&lt;/li>
&lt;li>iOS: wife&amp;rsquo;s clock (by feishu Calendar)&lt;/li>
&lt;/ul>
&lt;p>[生活]&lt;/p>
&lt;ol>
&lt;li>iPhone 11 Pro Max (256G)&lt;/li>
&lt;li>iPhone X (64G)&lt;/li>
&lt;li>iPad Pro 2019 12.9'&lt;/li>
&lt;li>Airpods Pro&lt;/li>
&lt;li>Bose QC30&lt;/li>
&lt;li>Year 2016, Sony 1A-DAC&lt;/li>
&lt;li>Year 2015, Sennheiser MOMENTUM&lt;/li>
&lt;li>Year 2013, Fujifilm X10&lt;/li>
&lt;/ol>
&lt;p>[过往]&lt;/p>
&lt;ul>
&lt;li>Year 2019, LG UL650&lt;/li>
&lt;li>Year 2018, PC(i5-8400 + 16G + GTX 1066)&lt;/li>
&lt;li>Year 2015, PC(E3-1230v3 + 16G + AMD 380X)&lt;/li>
&lt;li>Year 2015, iPhone 6&lt;/li>
&lt;li>Year 2013, Macbook Air 2013&lt;/li>
&lt;li>Year 2013, Samsumg WinPhone&lt;/li>
&lt;li>Year 2012, Meizu&lt;/li>
&lt;li>Year 2011, PC(i3-2100 + 8G + AMD graphic card)&lt;/li>
&lt;li>Year 2011, Sony VAIO Laptop&lt;/li>
&lt;li>Year 2011, Nikon D90&lt;/li>
&lt;li>Year 2010, iPhone 3Gs&lt;/li>
&lt;li>Year 2005, Lenovo PC&lt;/li>
&lt;/ul>
&lt;h2 id="我的存储">我的存储&lt;/h2>
&lt;ol>
&lt;li>OneDrive（文档，扫描件）&lt;/li>
&lt;li>&lt;del>坚果云&lt;/del>（存量 books与文献）&lt;/li>
&lt;li>阿里云盘（相册）&lt;/li>
&lt;li>百度网盘（各类资源）&lt;/li>
&lt;/ol>
&lt;h2 id="联系我">联系我&lt;/h2>
&lt;ol>
&lt;li>Gmail&lt;/li>
&lt;li>Outlook&lt;/li>
&lt;li>iCloud隐私邮箱&lt;/li>
&lt;/ol>
&lt;p>Last edited on 2022/03/11&lt;/p>
- https://akelio-zhang.github.io/posts/about-me/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>Git指南</title><link>https://akelio-zhang.github.io/posts/2021git%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 03 Jan 2022 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2021git%E6%8C%87%E5%8D%97/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2021git%E6%8C%87%E5%8D%97/ -&lt;h2 id="零目的">零、目的&lt;/h2>
&lt;ol>
&lt;li>掌握各类场景下如何更好使用Git。&lt;/li>
&lt;li>减少因为代码提交问题带来的生产环境问题。&lt;/li>
&lt;/ol>
&lt;p>&lt;img src="https://akelio-zhang.github.io/images/git-zoo.jpg" alt="Git几大工作区域一览">&lt;/p>
&lt;p>Git几大工作区域一览&lt;/p>
&lt;h2 id="一了解git">一、了解Git&lt;/h2>
&lt;ol>
&lt;li>什么是Git？
&lt;ol>
&lt;li>一款分布式版本管理系统&lt;/li>
&lt;li>优点：分布式、性能、版本的文件完整性
&lt;ol>
&lt;li>分布式，可以让你在本地提交代码（对于SVN而言没有网络就无法提交代码，在家也能愉快地写代码）；&lt;/li>
&lt;li>性能，对于我们的一般项目而言，你感受不到合并时性能的差别（与SVN比较）；&lt;/li>
&lt;li>版本的文件完整性：git背后设计理念是快照思想。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Git概念
&lt;ol>
&lt;li>仓库(repository)
&lt;ol>
&lt;li>用于代码版本管理&lt;/li>
&lt;li>一个git仓库管理了三棵“树”，分别是
&lt;ol>
&lt;li>Working Directory（工作目录）&lt;/li>
&lt;li>Index（暂存区）&lt;/li>
&lt;li>HEAD（本地仓库）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>大多数时候你通过编辑器只能对工作目录操作，操作其他两个“树”（区域）必须使用git命令才可以。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>分支(branch)
&lt;ol>
&lt;li>用于并行独立开发，更方便管理不同开发任务的进度&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>Git常用命令
&lt;ol>
&lt;li>git add&lt;/li>
&lt;li>git commit&lt;/li>
&lt;li>git push&lt;/li>
&lt;li>git pull&lt;/li>
&lt;li>git branch&lt;/li>
&lt;li>git switch&lt;/li>
&lt;li>git restore&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="二最常见的一种使用场景">二、最常见的一种使用场景&lt;/h2>
&lt;p>陈主管说他已经开发好了整个架构，需要我去把几个功能实现一下，并提交到dev分支让他方便Review。&lt;/p>
&lt;ul>
&lt;li>基本流程
&lt;ol>
&lt;li>先从远程服务器把代码拉到本地：&lt;code>git clone http://197.68.6.70/demo-project&lt;/code>&lt;/li>
&lt;li>此时你拥有的是主干master分支的代码，我们需要切换到dev分支进行开发：
&lt;ol>
&lt;li>&lt;code>git fetch --all&lt;/code>&lt;/li>
&lt;li>&lt;code>git switch --track origin/dev&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>在&lt;strong>工作目录&lt;/strong>写代码&lt;/li>
&lt;li>提交变更的文件到&lt;strong>暂存区&lt;/strong>：&lt;code>git add &amp;lt;somefile&amp;gt;&lt;/code>&lt;/li>
&lt;li>提交文件到&lt;strong>本地仓库&lt;/strong>：&lt;code>git commit -m &amp;quot;xxx&amp;quot;&lt;/code>&lt;/li>
&lt;li>把我的代码推送到远程仓库（同步）：&lt;code>git push&lt;/code>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ul>
&lt;h2 id="三最佳实践git里的后悔药">三、最佳实践——Git里的后悔药&lt;/h2>
&lt;ol>
&lt;li>我提交到暂存区的代码搞错了：&lt;code>git restore -S &amp;lt;files or dir&amp;gt;&lt;/code> （在使用IDEA时，这个场景不太会出现，因为IDEA往往是把add 和 commit的操作会合并成一个处理）&lt;/li>
&lt;li>我提交到本地仓库的代码搞错了：
&lt;ol>
&lt;li>最近的一个commit：&lt;code>git reset -mixed HEAD~1&lt;/code>&lt;/li>
&lt;li>历史中的一个commit：
&lt;ol>
&lt;li>使用 &lt;code>git reset --mixed &amp;lt;commit_id&amp;gt;&lt;/code>，然后重新提交正确的代码（ ❗从最新commit到指定commit的代码都需要重新提交）&lt;/li>
&lt;li>使用 &lt;code>git revert &amp;lt;commit_id&amp;gt;&lt;/code> ，这个操作近似于自己重新提交代码&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>我提交到远程仓库的代码搞错了：
&lt;ol>
&lt;li>只有一个建议：&lt;strong>请写出正确的代码，重新提交！所以，请在每次push之前谨慎！&lt;/strong>&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="四最佳实践与他人同步">四、最佳实践——与他人同步&lt;/h2>
&lt;ol>
&lt;li>我想把别人在dev分支上开发的代码同步下来看看：&lt;code>git pull --rebase&lt;/code> 或者 &lt;code>git pull&lt;/code> （前者会让你的commit log更加清爽一些，没有一些额外的merge commit log）&lt;/li>
&lt;li>如果你开发的分支和多人一同开发，建议每天进行一次 &lt;code>git pull --rebase&lt;/code> 与 &lt;code>git push&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="五最佳实践我的改动比较大">五、最佳实践——我的改动比较大&lt;/h2>
&lt;ol>
&lt;li>建议自己拉一个分支进行开发 &lt;code>git switch -c &amp;lt;new_branch_name&amp;gt;&lt;/code> 。&lt;/li>
&lt;li>开发结束后，先把&lt;strong>主开发分支&lt;/strong>合并到你的分支：&lt;code>git merge dev&lt;/code>&lt;/li>
&lt;li>没问题后再把你的分支合并到主开发分支：&lt;code>git switch dev&lt;/code> ，&lt;code>git merge &amp;lt;new_branch_name&amp;gt;&lt;/code>&lt;/li>
&lt;/ol>
&lt;h2 id="六其他">六、其他&lt;/h2>
&lt;ol>
&lt;li>⭐准备上线前
&lt;ol>
&lt;li>和上一个版本代码对比(&lt;code>git diff release master&lt;/code>)，确认release分支是&lt;strong>正确的需要上线的代码&lt;/strong>&lt;/li>
&lt;li>使用Jenkins对release分支进行自动打包与部署，在工作空间获取上线代码包（禁止本地打包）&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>上线完成后
&lt;ol>
&lt;li>在gitlab上提交release合并至master分支的merge request，由技术经理确认合并；&lt;/li>
&lt;li>对最新的master分支进行tag，方便反查源码；&lt;/li>
&lt;/ol>
&lt;/li>
&lt;/ol>
&lt;h2 id="七几个原则">七、几个原则&lt;/h2>
&lt;h3 id="强制">强制&lt;/h3>
&lt;ol>
&lt;li>禁止&lt;code>git push -f&lt;/code>&lt;/li>
&lt;li>禁止&lt;code>git push master&lt;/code>&lt;/li>
&lt;/ol>
&lt;h3 id="建议">建议&lt;/h3>
&lt;ol>
&lt;li>建议分支命名：master、release、dev、dev_xx
&lt;ol>
&lt;li>master分支为线上正在运行的代码；不允许手动提交；只能通过页面的merge request进行代码合并；每次上完线后把分支(release)代码合并到master&lt;/li>
&lt;li>release为测试环境对应的代码，jenkins均从该分支进行自动构建与部署&lt;/li>
&lt;li>dev，以及其他分支为开发分支，较为自由。&lt;/li>
&lt;/ol>
&lt;/li>
&lt;li>减少对&lt;code>git checkout&lt;/code>的使用，已经拆分为 &lt;code>git switch&lt;/code> 和 &lt;code>git restore&lt;/code>&lt;/li>
&lt;li>不要把二进制文件放到git仓库中进行版本管理&lt;/li>
&lt;/ol>
&lt;h2 id="八实现方式之数据结构">八、实现方式之数据结构&lt;/h2>
&lt;p>在Git当中，&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-markdown" data-lang="markdown">// 一个文件就是字节数组
type blob = array&amp;lt;&lt;span style="color:#8b008b;font-weight:bold">byte&lt;/span>&amp;gt;
// 一个目录包含文件或者其他目录
type tree = map&amp;lt;&lt;span style="color:#8b008b;font-weight:bold">string&lt;/span>&lt;span style="color:#a61717;background-color:#e3d2d2">,&lt;/span> &lt;span style="color:#658b00">tree&lt;/span> &lt;span style="color:#a61717;background-color:#e3d2d2">|&lt;/span> &lt;span style="color:#658b00">blob&lt;/span>&amp;gt;
// 一个commit包含它的父节点，原始信息，顶级目录（快）
type commit = struct {
parents: array&amp;lt;&lt;span style="color:#8b008b;font-weight:bold">commit&lt;/span>&amp;gt;
author: string
message: string
snapshot: tree
}
// 文件、目录、commit最终都以object类型进行存储
type object = blob | tree | commit
&lt;/code>&lt;/pre>&lt;/div>&lt;p>这样看起来，每一次修改文件并提交git仓库后，都会新建一个blob对象，并作为新的快照内部的文件使用，因此，git仓库存储空间可能会越来越大，特别是对于那些二进制文件（非文本文件，难以压缩）。这时候可以通过&lt;code>git gc&lt;/code>进行git仓库压缩，这里面的算法大家可以自己去探索一下。根据我的经验，能大概缩小到原本的1/3~1/2。&lt;/p>
&lt;h2 id="九参考">九、参考&lt;/h2>
&lt;h3 id="cheatsheet">Cheatsheet&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://ndpsoftware.com/git-cheatsheet.html#loc=index;">一个可视化的Git Cheatsheet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://about.gitlab.com/images/press/git-cheat-sheet.pdf">Gitlab官方Cheatsheet&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://github.com/k88hudson/git-flight-rules">https://github.com/k88hudson/git-flight-rules&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6">Git - 高级合并 (git-scm.com)&lt;/a>&lt;/li>
&lt;/ol>
&lt;h3 id="原理学习">原理学习&lt;/h3>
&lt;ol>
&lt;li>&lt;a href="https://draveness.me/whys-the-design-git-the-best/">为什么你应该使用 Git 进行版本控制 - 面向信仰编程 (draveness.me)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://www.progit.cn/">Pro Git 中文版（第二版）&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://missing.csail.mit.edu/2020/version-control/">Version Control (Git) · the missing semester of your cs education (mit.edu)&lt;/a>&lt;/li>
&lt;/ol>
&lt;h2 id="some-code">Some code&lt;/h2>
&lt;div class="highlight">&lt;pre tabindex="0" style="background-color:#eed;-moz-tab-size:4;-o-tab-size:4;tab-size:4">&lt;code class="language-bash" data-lang="bash">git clone
git branch --track dev origin/dev
git checkout dev
git add &amp;amp; git commit
git push
Merge Request (MR)
git restore -S &amp;lt;files or dir&amp;gt;
git reset -mixed HEAD~1
git reset --mixed &amp;lt;commit_id&amp;gt;
git revert &amp;lt;commit_id&amp;gt;
git pull --rebase
git pull
git checkout -b &amp;lt;branch_name&amp;gt;
...
git merge dev
git stash
git stash pop
&lt;/code>&lt;/pre>&lt;/div>- https://akelio-zhang.github.io/posts/2021git%E6%8C%87%E5%8D%97/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>[2020]互联网技术社招总结</title><link>https://akelio-zhang.github.io/posts/2020%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E6%8B%9B%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 28 Mar 2021 18:00:00 +0000</pubDate><guid>https://akelio-zhang.github.io/posts/2020%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E6%8B%9B%E6%80%BB%E7%BB%93/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2020%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E6%8B%9B%E6%80%BB%E7%BB%93/ -&lt;h1 id="准备">准备&lt;/h1>
&lt;h3 id="用人单位招聘诉求">用人单位招聘诉求&lt;/h3>
&lt;p>对于每个用人单位来说，他们有两个诉求：1.招聘到能够立马(尽快)胜任工作并解决业务痛点的人；2.减少用人成本。&lt;/p>
&lt;p>往往第二点是和招聘人利益是冲突的，所以我们只能通过第一点来进行突破，也就是大家常说的你要和你的岗位有较高的匹配度。&lt;/p>
&lt;p>对于互联网岗位软件工程师来说，我认为有三方面可以讨论&lt;strong>匹配度：1.技术理解深度；2.业务场景理解以及抽象转换的能力；3.团队管理能力。&lt;/strong>&lt;/p>
&lt;h3 id="简历完善">简历完善&lt;/h3>
&lt;p>简历是面试双方的书面信息，其目的是为了使得面试官对面试者产生好奇心，且协助双方在面试过程更有内容可说。因此，可以从以下几个角度思考简历是否可以进一步优化。简历虽然很重要，但是也没必要说做到尽善尽美，主要原则还是信息准确以及一定的美观。&lt;/p>
&lt;ol>
&lt;li>信息是否罗列明确且无缺失。&lt;/li>
&lt;li>可量化的地方尽可能做量化。&lt;/li>
&lt;li>个人特色是否体现在简历之上(最好是对工作有贡献的)。&lt;/li>
&lt;li>内容是否与目标岗位有比较好的匹配度。&lt;/li>
&lt;/ol>
&lt;h3 id="个人状况">个人状况&lt;/h3>
&lt;p>在做面试准备之前，先要了解个人的软硬技能方面的状况来发现匹配度上的差异，以做针对性的准备。&lt;/p>
&lt;h3 id="面试准备">面试准备&lt;/h3>
&lt;p>在面试中，往往会有以下几块内容的沟通：&lt;strong>个人介绍、项目介绍、算法题、系统设计题、专业知识、技术方案、向面试官提问&lt;/strong>。系统设计题往往出现在后面几轮部门领导的面试，算法、专业知识则通常出现在第一二轮。技术方案则都会有所涉及。&lt;/p>
&lt;p>在社招中，大部分公司会更注重你&lt;strong>过往的项目经历&lt;/strong>，且会在项目上挖掘你的专业知识以及难点技术方案。所以这一块需要深入剖析，包括技术方案、业务场景、拥抱变化的能力(高可用、高并发)等常见的互联网应用的问题。&lt;/p>
&lt;p>由于近些年计算机大厂竞争愈发激烈，算法题与专业知识也经常单独进行考察。算法题一般就刷LeetCode中等就可以；专业知识包括数据结构、操作系统、网络、你的主语言使用理解等。&lt;/p>
&lt;p>对于向面试官提问，有人说很重要，但是我认为这往往是锦上添花的效果。主导你拿到offer的还是前面提到的基本面。这一块通常体现了你对这份工作的向往程度。&lt;/p>
&lt;p>贵司一天工作的时间线大概是怎么样的？&lt;/p>
&lt;p>印象最深的一次工作内容是什么？&lt;/p>
&lt;p>最近加班频繁吗？&lt;/p>
&lt;p>最后，一场面试，当你说话的时间占比越大，往往就越有可能顺利通过。&lt;/p>
&lt;h1 id="过程">过程&lt;/h1>
&lt;ol>
&lt;li>中小厂&lt;/li>
&lt;/ol>
&lt;p>中小厂对人的要求很直白，能干活，最好技术栈比较贴合，如果面试者过往接触的业务一致性一样就更好了。笔者经历了杭州的一家互联网券商的面试，整体体验感难度适中，问题也都比较贴合实际开发过程会碰到的问题。这也可能是因为整体技术栈重合度较高的原因。算法题、专业知识、技术方案（并发、消息、缓存、Scala）。没有涉及系统设计。&lt;/p>
&lt;ol>
&lt;li>大厂&lt;/li>
&lt;/ol>
&lt;p>国内大厂面试风格分为两派，项目技术方案为主与算法为主。前者主要在于项目这一块会问的非常深入，并随之伴随各类技术方案的讨论，强调实战经验。后者对于社招也要提出相当的算法与专业知识的要求，以便于进行高效的过滤。&lt;/p>
&lt;p>大厂的算法题会结合更实际的场景来出题，而非LeetCode的原题。比如，提供一天登录登出日志文件(time, uid, action)，问如何计算得到在线人数峰值时间点以及90%峰位时间点。&lt;/p>
&lt;p>大厂的项目介绍与技术方案往往是大头部分，面试官会从各个角度来测试你工作的含金量与价值。业务问题如何抽象设计、系统如何拆分设计、如何应对未来的大流量、中间件的选择考虑点等。这块可以参考&lt;a href="https://github.com/donnemartin/system-design-primer">system-design-primer&lt;/a>。&lt;/p>
&lt;ol>
&lt;li>外企&lt;/li>
&lt;/ol>
&lt;p>外企确实与国内企业差别很大，面试体验感很不错，你会感觉到你被认真对待。往往会在1天完成所有的面试。面试轮次会在3-4次。笔者面试的岗位更偏向于业务部门，所有问题都围绕实际场景展开。比如，算法题是设计一个类，提供两个操作：记录当前系统的负载和返回近5分钟的平均负载。另一个是设计一个命令行工具，实现对参数的读取与处理。&lt;/p>
&lt;p>外企社招时对员工的要求普遍较高，并非单靠刷题就可以。比如在系统题中会考察如何进行项目管理，如何测试，如何运维等等非常全面的问题。另一方面，由于外企的产品往往面向全球，会有诸如如何解决多地数据中心同步的问题、攻击网关设计等国际化的问题。&lt;/p>
&lt;h1 id="结论">结论&lt;/h1>
&lt;p>在面试的准备与进行过程中，是对我们自己过往的一次总结与提升。面试失败也不必过于难过，不是每个面试官都是那么专业，也可能是你与这家公司这个岗位目前仍然不那么契合。&lt;/p>
&lt;p>每一个人有每一个人的特色与优劣势，每一家公司有每一家公司的喜好。我们能做的就是保持自信，扬长避短，以一种积极友善的态度把握整个面试过程的主动性（比如有些面试官说让你简单说说xxx，此时若是你擅长的，你应该抓住机会表现出你的特色）&lt;/p>
&lt;h1 id="站在巨人的肩膀上">站在巨人的肩膀上&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://www.imwzk.com/posts/2020-10-05-an-incomplete-guide-to-campus-recruitment-interviews/">校招面试不完全指南&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://mindhacks.cn/2011/11/04/how-to-interview-a-person-for-two-years/">怎样花两年时间去面试一个人&lt;/a>&lt;/li>
&lt;/ol>
- https://akelio-zhang.github.io/posts/2020%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E7%A4%BE%E6%8B%9B%E6%80%BB%E7%BB%93/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>系统复杂度-1</title><link>https://akelio-zhang.github.io/posts/2020%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/</link><pubDate>Sat, 06 Jun 2020 18:00:00 +0000</pubDate><guid>https://akelio-zhang.github.io/posts/2020%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2020%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/ -&lt;h1 id="0x1-introduction">0x1 Introduction&lt;/h1>
&lt;p>当你接手一个不熟悉的系统的时候，你可能想找一下系统文档（但是已经很久没更新了）；你可能想看一下有没有单元测试（很多根本跑不起来了）；这时候，除了问同事，只能自己从几千几万行代码中开始摸索。&lt;/p>
&lt;p>当你开发一个新系统的时候，由于某些原因需要调整局部的逻辑，因为没有相应的单元测试，结果在移交给测试后才发现各种顾此失彼的bug出现了。&lt;/p>
&lt;p>当你的系统性能已经无法再满足时，又或者系统的迭代成本异常大时，此时就会可能需要重写或重构。此时，由于没有单元测试，自动化集成测试，你不得不拉上更多的同事来参与此次系统优化，以保证系统的可靠性。&lt;/p>
&lt;p>当你的系统需要有新的客户接入时，因为没有最新的系统文档或使用说明书，你只能电话、口头地来教别人怎么接入你的系统。&lt;/p>
&lt;p>上述的几个场景，都是因为系统的配套设施（文档、测试）没有同步完善，引起接入、迭代、重构的成本显著增加。这不是我们想看到的。相对地，系统的快速迭代的开发模式已经受到了广泛的认同，我们怎么在这个过程能够一直保持高效、可靠的输出呢？对于这个问题，本文尝试从系统复杂度、重构、设计模式、测试这几个角度来讨论这个问题，希望能给大家一些新的思考。&lt;/p>
&lt;h1 id="0x2-系统复杂度">0x2 系统复杂度&lt;/h1>
&lt;p>首先，算法有复杂度一说，在所有的算法课程基本都会在前1-2章围绕这个话题展开详细的定义与分析讨论。算法复杂度一般分为时间复杂度与空间复杂度，可以说是该算法解决问题的时间与空间成本。&lt;/p>
&lt;p>在工作上，我们维护的往往是一个系统，一个工程。一个系统的复杂度定义，似乎并不是那么容易。本章节大多数内容来源于&lt;em>A Philosiphy of Software Designing&lt;/em>。这本书中对于系统的复杂度定义非常的实际，&lt;strong>软件系统结构中让其变得难以理解且难以变更的部分组成了系统的复杂性&lt;/strong>。回顾本文引子部分，其实都是系统难以理解、难以修改导致的结果。&lt;/p>
&lt;p>这个定义相对于算法复杂度而言，显得非常主观，没有客观的评估准则，各个人的理解也会大相径庭。因此，书中进一步展开了几种复杂性症状。&lt;/p>
&lt;ol>
&lt;li>变化放大(change amplication)：当你需要改动某一个逻辑时，会涉及到多处代码变更。&lt;/li>
&lt;li>认知负担(cognitive load)：有时尽管只写了很少的代码，但是对于他人来说异常难以理解，请尝试将它改写成容易理解的方式。&lt;/li>
&lt;li>不可知(unknown unknowns)：不知道哪里有坑存在，就算BUG出现了。&lt;/li>
&lt;/ol>
&lt;p>总的来说，控制住整个系统的复杂度，将是保障我们高效、可靠工作的核心。低复杂度的系统，大大降低了开发过程中的心智压力。&lt;/p>
&lt;h1 id="0x3-测试">0x3 测试&lt;/h1>
&lt;p>为什么要把测试放在靠前的位置呢？测试是将一直伴随在生产代码演进的，是软件的&lt;strong>可靠性&lt;/strong>保证的重要工具。&lt;/p>
&lt;p>拿建筑工程做一个类比，设计一幢房屋时，对于设计人员，最终产出的是施工图。那么，它的设计依据是什么呢？《规范》与模型的承载能力分析。前者，描述了什么类型的结构需要怎么样的设计，这种属于基本要求。后者，通过基于物理建模软件进行专门的结构性能分析，来确保本次设计的&lt;strong>可靠性&lt;/strong>。&lt;/p>
&lt;p>软件工程相比建筑工程，非常年轻，一方面没有条条框框地规则（P3C也仅仅是一些基础性条约）；另一方面，因为大部分软件工程不涉及生命财产，也可以通过快速更新来解决问题，所以导致大多数人对&lt;strong>可靠性&lt;/strong>的关注度远不如建筑工程。先不说这样的态度容易使生产问题频发，另外也会让你的工作开展体验感相对差劲，总是在返工。&lt;/p>
&lt;p>因此，我们需要在注重软件的可靠性。我们的第一个工具就是（自动化）测试。好的测试，就能够有效地模拟真实地业务场景，来校验代码的正确性。好的测试，能够让新加入的开发人员更容易理解系统是如何使用的。好的测试，能够促进系统架构的合理化——高内聚低耦合。但是，好的测试代码并不容易写，因为测试代码的思考方式与一般的coding并不一样，它更像是生产代码的前置条件、运行场景。&lt;/p>
&lt;p>测试通常分为四个层次：单元测试（Unit Testing）、集成测试（Integration Testing）、系统测试（System Testing）、验收测试（Acceptance Testing）。其中离开发最近的是单元测试，一般覆盖的是函数以及类的功能正确性。集成测试则是对系统内部的各模块之间的协作是否正确，通常按内部接口进行覆盖测试。系统测试则是验证对外接口能否在各种情况下能够正常地运行（性能测试也属于这一层次）。验收测试属于辅助性的测试，范围也相对更广，不同的系统也会需要不同的验收测试，例如安全测试、易用性测试、兼容性测试等等。&lt;/p>
&lt;p>这里我们主要谈一下单元测试，因为这是所有测试的基本面，也是开发人员所需要特别关注的地方。先考虑一下是先写生产代码还是先写测试代码。第一个角度是，当然是先写生产代码了，没有生产代码怎么测试呢？第二个角度是，先写测试代码再写生产代码，因为测试代码是功能的运行场景，只有先把这些前置条件搞清楚了，才能写出正确的生产代码。也许你会说，我可以先大脑过一下基本场景，然后再写生产代码，再写测试代码，这应该是大部分人目前的方式，但是不知道你有没有发现，这种方式写出来的测试代码往往会因为前期的假设导致覆盖率很低。&lt;/p>
&lt;p>在2003年，Kent Beck提出了Test-Driven development（TDD）这样一种开发模式。&lt;/p>
&lt;ol>
&lt;li>添加一个测试&lt;/li>
&lt;li>运行所有测试，是否有失败&lt;/li>
&lt;li>一旦有失败的测试，就开始写生产代码，直到该测试通过为止。&lt;/li>
&lt;li>所有测试通过后，就必须开始写测试代码，直到有一个测试无法通过。&lt;/li>
&lt;/ol>
&lt;p>可能，你会觉得这样非常耗时，但是你得明确，你在一个功能开发的耗时并不仅仅是写了那一堆生产代码而已，还包括测试、代码修复等等。所以，这种方式只是将一些顺序进行了调换，却能为最终的正确性铺垫很多。&lt;/p>
&lt;h1 id="0x4-重构">0x4 重构&lt;/h1>
&lt;p>重构与重写都是试图优化系统复杂度的方式，在不同的场景（代码状况、工期等）会选择不同的方式，但是大多时候会采用重构的方式来实现。&lt;/p>
&lt;p>先来看一下wikipedia对重构的定义：&lt;/p>
&lt;p>In &lt;a href="https://en.wikipedia.org/wiki/Computer_programming">computer programming&lt;/a> and &lt;a href="https://en.wikipedia.org/wiki/Software_design">software design&lt;/a>, &lt;strong>code refactoring&lt;/strong> is the process of restructuring existing &lt;a href="https://en.wikipedia.org/wiki/Computer_code">computer code&lt;/a>—changing the &lt;em>&lt;a href="https://en.wikipedia.org/wiki/Decomposition_(computer_science)">factoring&lt;/a>&lt;/em>—without changing its external behavior. Refactoring is intended to improve the design, structure, and/or implementation of the &lt;a href="https://en.wikipedia.org/wiki/Software">software&lt;/a> (its &lt;em>&lt;a href="https://en.wikipedia.org/wiki/Non-functional_requirement">non-functional&lt;/a>&lt;/em> attributes), while preserving its &lt;a href="https://en.wikipedia.org/wiki/Functional_requirement">functionality&lt;/a>. Potential advantages of refactoring may include improved code &lt;a href="https://en.wikipedia.org/wiki/Readability">readability&lt;/a> and reduced &lt;a href="https://en.wikipedia.org/wiki/Cyclomatic_complexity">complexity&lt;/a>; these can improve the &lt;a href="https://en.wikipedia.org/wiki/Source_code">source code&lt;/a>&amp;rsquo;s &lt;a href="https://en.wikipedia.org/wiki/Maintainability">maintainability&lt;/a> and create a simpler, cleaner, or more expressive internal &lt;a href="https://en.wikipedia.org/wiki/Software_architecture">architecture&lt;/a> or &lt;a href="https://en.wikipedia.org/wiki/Object_model">object model&lt;/a> to improve &lt;a href="https://en.wikipedia.org/wiki/Extensibility">extensibility&lt;/a>.&lt;/p>
&lt;p>在系统复杂度膨胀到一定程度后，添加功能异常困难、系统变得难以理解、修改的时候，重构往往就需要开始执行，从而降低系统的复杂度，让我们能够更高效地开发、修改代码。所以重构并不是某一个开发阶段，而是一种开发工具，帮助我们提升效率。&lt;/p>
&lt;p>在《重构》这本书中，提到很多地坏味道，本质就是一些让系统复杂度变高的地方，你可以发现它与第二节中的那些症状很类似。&lt;/p>
&lt;p>这里特别想说的是，重构的过程中，其实会采用不少设计模式，但是并不能说设计模式就是万能药。设计模式是我们需要了解的，但是我们需要记住的是它们出现的目的是什么，我这里可以列举几个：&lt;/p>
&lt;ol>
&lt;li>减少继承，多采用组合的方式来丰富类的功能。&lt;/li>
&lt;li>面对各种功能的变更，能够将变化（影响）的范围尽可能的缩小到1个或者少量的类中。&lt;/li>
&lt;li>面向接口编程。&lt;/li>
&lt;/ol>
&lt;h1 id="0x5-结论">0x5 结论&lt;/h1>
&lt;ol>
&lt;li>除了写好生产代码以外，我们要多多关注一些周边的工具：自动化测试、持续继承、文档等。&lt;/li>
&lt;li>对于一个持续迭代的系统，系统复杂度是需要重点关注的。&lt;/li>
&lt;li>尝试把你的测试代码前置。&lt;/li>
&lt;li>重构能够帮助你降低系统复杂度。&lt;/li>
&lt;li>三次原则：第一次做某件事时只管去做；第二次做类似的事会产生反感（蹩脚），但无论如何还是可以去做；第三次再做类似的事，你就应该重构/反思。&lt;/li>
&lt;/ol>
&lt;h1 id="站在巨人的肩膀上">站在巨人的肩膀上&lt;/h1>
&lt;ol>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Software_testing#Testing_levels">https://en.wikipedia.org/wiki/Software_testing#Testing_levels&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://en.wikipedia.org/wiki/Code_refactoring">https://en.wikipedia.org/wiki/Code_refactoring&lt;/a>&lt;/li>
&lt;li>Ousterhout, John. &lt;em>A Philosophy of Software Design&lt;/em>. Yaknyam Press, 2018.&lt;/li>
&lt;li>Fowler, Martin. &lt;em>Refactoring: improving the design of existing code&lt;/em>. Addison-Wesley Professional, 2018.&lt;/li>
&lt;li>Martin, Robert C. &lt;em>The clean coder: a code of conduct for professional programmers&lt;/em>. Pearson Education, 2011.&lt;/li>
&lt;/ol>
- https://akelio-zhang.github.io/posts/2020%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/ - 2019-2022 Akelio All rights reserved.</description></item><item><title>[2020]Clean系统读书笔记——两年项目回顾</title><link>https://akelio-zhang.github.io/posts/2020clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/</link><pubDate>Wed, 27 May 2020 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2020clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/</guid><description>LIFE CODER https://akelio-zhang.github.io/posts/2020clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/ -&lt;h1 id="2020clean系统读书笔记两年项目回顾">[2020]Clean系统读书笔记——两年项目回顾&lt;/h1>
&lt;h2 id="0x1-引子">0x1 引子&lt;/h2>
&lt;p>这是一篇在快速浏览了一圈《Clean Code》《Refactoring》《Clean Coder》这三本书之后的读后感。仅作为一篇备忘录。&lt;/p>
&lt;p>在很早很早时候，开始准备转CS的时候就知道了Refactoring这本书，当时很简单地扫了一眼，就感觉很多东西都不明所以，要么就觉得，这不是本该就这样吗？于是就一直扔在网盘没再看过。&lt;/p>
&lt;p>软件工程 VS 建筑工程&lt;/p>
&lt;blockquote>
&lt;p>深思，结构设计与IT系统设计，都是一种系统设计，但是结构设计相对来说 约束比较明确，量化也很明确，干嘛的，负载多少，并且建筑设计已经进一步做了一层约束，所以到结构这边，整个外界的条件已经很丰富了，所以针对这个相对来说 应该有比较容易的解答了。相反，在IT系统这边，往往需求开始就是模糊的，体量也是预计的，往往后期会增加，还会有那些“灰色”流量。这些难以量化的约束，使得在整个系统设计上就变得很困难，因为没有万能的系统。并且系统能够承载的东西，往往随着时间会变得越来越丰富，这时候如果早期的设计比较局限，就可能要整体重构等等。在这种宽约束下的系统设计能力，需要好好锻炼。「一次交付和不断迭代的产品」—— by C. Gen&lt;/p>
&lt;/blockquote>
&lt;p>那么，就先从2018年开始回顾。&lt;/p>
&lt;h2 id="0x2-2018-function-works">0x2 &lt;strong>2018 Function works!&lt;/strong>&lt;/h2>
&lt;p>18年开始工作之后，一开始只是做一些很简单地Feature的增加，大约一个Feature只设计100行代码左右。所以基本就是在1-2个函数可以解决问题，也不太涉及OO方向的变更（采用系统本身的设计即可），所以在18年这个时间点上，主要是在函数层面做工作，各种类也是相对独立地使用，更多关注的是功能正常和简单的单元测试。&lt;/p>
&lt;p>除此以外，很多时间是在熟悉团队的各个系统的定义与功能，（&lt;a href="http://t.cn/A6AiEuUl">如何快速熟悉一个系统&lt;/a>）以及各种容器、工具（IDEA、Maven、Tomcat、Dubbo、Vue、Element、CI、Logback、Restful MVC、MyBatis&amp;hellip;）的熟悉了解。&lt;/p>
&lt;p>总结来说，2018年在熟悉基本工作外，在不断地打开(broaden)自己的知识网络。&lt;/p>
&lt;h2 id="0x3-2019-流程系统痛点解决大数据起步">0x3 &lt;strong>2019 流程系统，痛点解决，大数据起步&lt;/strong>&lt;/h2>
&lt;blockquote>
&lt;p>设计文档，流程图，UML，DDD&lt;/p>
&lt;/blockquote>
&lt;p>2019年开始，阴差阳错处于空档期，接了一个项目（当时其实就是很迫切地想做一些大一点的项目，来提升自己的能力，也没有对需求去做直接的评估）。现在回头再看，这个项目属于一个非常偏向业务的功能模块开发（从技术角度并没有太多需要考量的点，流量也是比较小的）。涉及到要开发的点有前端页面，中后台运营平台的开发，后台系统的业务流程（较复杂，场景较多）处理。&lt;/p>
&lt;p>当时，基本就和同事定了一下大体的功能点放在哪些模块，以及表结构的设计，就直接开始动手写了。设计文档无，流程图无，这导致后期开发维护都变得很困难，好在是在第三期的时候补充了不少。&lt;/p>
&lt;p>相比18年的函数级别的开发，这项目涉及到了多个系统，一条业务请求的多次变更，各种异步处理。要考虑地就更多了：核心类如何设计，每个流程的具体设计（需要由哪些类来支撑），系统与系统之间的交互设计等等（项目中涉及到Redis、MQ、RPC、DB这样四种方式来进行数据交互）。&lt;/p>
&lt;p>至此，让我充分意识到设计文档、流程图、UML等图文，对于一个项目的意义有多大了，它们不光指导了当前的开发工作，还为未来的迭代开发节约了大量的时间。&lt;/p>
&lt;p>PS. 由于流程复杂，单元测试也基本没怎么做，之后测试BUG较多。带有数据源的单元测试如何做？&lt;/p>
&lt;p>基于Mybatis，Jar包统一了多个系统的结果码合并逻辑。&lt;/p>
&lt;p>基于Dubbo Cluster SPI优化了规则发布效率。&lt;/p>
&lt;p>大数据起步，数据匹配、变量能效评估系统。Scala、Spark、Impala、Hive。&lt;/p>
&lt;p>总结来说，2019年在拓展知识（大数据）的同时，发现了自己的系统设计这一块的不足，简单了解了设计文档、UML、流程图、DDD、贫血模型等。此外，还算是比较努力地尝试改善了当前系统中地一些顽固点（职责收拢、提高性能）。&lt;/p>
&lt;h2 id="0x3-2020-高流量的实时系统设计">0x3 &lt;strong>2020 高流量的实时系统设计&lt;/strong>&lt;/h2>
&lt;blockquote>
&lt;p>实现细节文档，TDD，类单一职责（只有一个原因发生变更）、减少类之间的知识(class, function and etc.)共享坏味道的嗅觉开发指导&lt;/p>
&lt;/blockquote>
&lt;p>先提一嘴，在2020参与的一些面试中，发现对于Spring这一块的问题已经非常非常少了，问的最多的可能也就是AOP和事务实现这一块了。一方面是可能大家对于Spring这块较为熟悉了，另一方面是Spring在我看来已经越来越不适合目前大流量的场景（相对来说比较臃肿，对分布式这一块的原生支持也比较弱，尽管已经有了Spring Cloud），一些新的框架（如Vert.x、Micronaut等）在分布式这一块是在设计初期就考虑进去的。&lt;/p>
&lt;p>同时，在知乎一个问题上的一个问题——&lt;em>Spring是否代表着目前Java技术的顶峰，未来的Java将如何发展？&lt;/em>。我觉得这个问题下面有个回答很有意思，php之于Web开发，Spring之于Java是很类似的地位。&lt;/p>
&lt;p>总的一句话，不要抱着老的东西不放，但也要取其精华。&lt;/p>
&lt;p>2020年，注定是一个非同寻常的一年，今年到现在，主要就在围绕实时计算平台做工作。&lt;/p>
&lt;p>2月基本在做关于提高性能的预研工作（目前我们大系统都以同步调用为主，导致在IO这一块会浪费比较多的资源），因此在异步、协程这一块做了比较多的调研工作，这一块到时候可以单独写一篇文章聊一聊这些模型。总的来说异步回调的写法其实比较反人类，callback hell导致可读性急剧下降。协程本质是一种用户级的调度，免去了陷入到OS内核的开销，但是还是存在一定的overhead，所以性能层面讲异步回调还更好一些。另外还有几种针对并发的模型：Actor和CSP，这两个回避了过去共享内存的数据交互方式，采用消息来进行沟通。我感觉这两个更接近面向对象的思维，也贴近真实生活中人与人的协作方式（讲话、邮件）。&lt;/p>
&lt;p>3-4月就属于开始编码的阶段，最困难的还是类的设计（包括成员以及实现的函数）。就讲讲返工，以及代码让自己感觉比较geying的几个场景吧。&lt;/p>
&lt;ol>
&lt;li>计算实现的细节，从A-&amp;gt;B-&amp;gt;C，做了三版。A的主要问题是，内存计算与IO线程混用影响整体性能。B，从业务角度考虑，可用性较差。C，当前的实现，为了系统实现上的简化，仍然对业务提出了一些要求，但是目前认为较合理。&lt;/li>
&lt;li>对于系统内部全流程都使用的类，建议不要直接使用API包中的类，比较受限制。&lt;/li>
&lt;li>操作一个类中的数据，只能使用这个类提供的方法，而不能直接操作成员变量。（例如，getMap().put(key, value)，这种写法会让后期维护成本很大）&lt;/li>
&lt;li>不要过早重构（extract method、类的抽象），因为此时很多问题还没有真正暴露。&lt;/li>
&lt;li>异常定义也需要写进设计文档。&lt;/li>
&lt;li>不要试图复用同一个单元测试，如果要增加测试case，就直接新增。&lt;/li>
&lt;/ol>
&lt;p>总的来说，花2个月的时间来实现这个系统（底层代码是基于已有的工程修改），我认为是比较久了。那么，现在回顾想想有哪些方式可以提高效率的。&lt;/p>
&lt;ol>
&lt;li>模板工程。每次的工程搭建、CI、机器申请还是花了不少时间的。&lt;/li>
&lt;li>有计划性的功能实现排期。能够很清楚当前自己的进度，方便管理整个项目的进度，也容易对上反馈。&lt;/li>
&lt;li>TDD，测试驱动能够尽早发现细节问题，并及时反馈调整。另一方面，重构时，这些是基础保障。&lt;/li>
&lt;li>to be added.&lt;/li>
&lt;/ol>
&lt;h2 id="0x4-读书总结">0x4 &lt;strong>读书总结&lt;/strong>&lt;/h2>
&lt;p>本文初衷是想一下3天阅读的三本书的感想，《Clean Code》、《Clean Coder》、《Refactoring》。&lt;/p>
&lt;p>首先，这三本书都是针对工程实现而言的，属于软件工程(Software Engineering)范畴。Clean Code、Refactoring这两本书提供一些思路帮助你去写出较低复杂性的系统，其中Clean Code更偏向指导纲要，Refactoring则更偏向实操，从各种具体案例来说明如何解决类似的问题。Clean Coder则是关于如何做一名更专业的开发人员的书，覆盖面更广，深度也会浅不少。&lt;/p>
&lt;p>那就按喜好程度，分别讨论一下书上的内容吧！&lt;/p>
&lt;h3 id="refactoring">Refactoring（⭐⭐⭐⭐⭐）&lt;/h3>
&lt;p>选它排第一的有两点：1. 真真正正的一本可实操的cook book；2. 我们大多时候需要面对的是对已有系统的修改，所以需要用到重构的方式方法。&lt;/p>
&lt;p>虽然是一本很实在的cook book，但是作者仍然保留了总结性质的内容在开头。什么是重构？为什么需要重构？什么时候开始重构？这三个重要的问题，已经在书的第二章很详细的说明了。还有一点是关于&lt;strong>重构与间接层&lt;/strong>，很多重构的结果就是引入了间接层（中间层）来协助拆分以前过长的函数、过大的类，还能隔离变化，但是仍然一定程度上降低了代码的可读性。所以，虽然大部分重构是在增加间接层，但是仍有一部分重构会尝试消除一些不必要的间接层。同一个间接层，在系统的不同阶段会呈现出不一样的意义。&lt;/p>
&lt;p>第三章，作者总结了一些会影响系统可维护性、可阅读性的22个特征。我在这里简单再做几个关键词总结：过长、过大、重复、过多的耦合、类的变化不受控、继承、注释。&lt;/p>
&lt;p>后续第6-11章，作者从函数、类、表达式这三个方面提供了几十种重构的方式。&lt;/p>
&lt;p>最后，也是比较重要的，重构的基础是完备的自动化测试，有时重构不如重写。&lt;/p>
&lt;p>PS. 重构与设计模式的关系，很多重构的结构是实现了某一种设计模式，但是他们两个都不是目的，最终目的都是降低系统的复杂性。重构是一种脚踏实地的过程，设计模式更多是中间的副产品。&lt;/p>
&lt;h3 id="clean-code">Clean Code（⭐⭐⭐⭐）&lt;/h3>
&lt;p>这本书就像一本指导纲要，告诉你要在哪些方面注意，来维持系统较低的复杂度。但是，程序员总是希望有一些最佳实践（其实在系统设计这一块，很难有最佳实践）。所以，这本书也需要常读常新。&lt;/p>
&lt;p>目前看完我觉得可以多做参考是函数、对象和数据结构、类、单元测试这四章。&lt;/p>
&lt;p>我这次读完，感受最深的是单元测试这一章，它很大程度上提升了coder的信心。test之于生产代码，就像结构模型之于设计图，它能够验证你的想法，验证你的系统的可靠性（一定程度）。&lt;/p>
&lt;p>关于单元测试，首先是TDD以及它的实践三大定律。第二，测试代码的可读性。第三，每一个测试仅做一个概念的测试。其他，F.I.R.S.T，快速、独立、可重复、自验性、及时。&lt;/p>
&lt;h3 id="clean-coder">Clean Coder（⭐⭐⭐）&lt;/h3>
&lt;p>这本书，很多东西可能不太适应国内的当前环境。我把写的比较有共鸣的几章拿出来说一说。&lt;/p>
&lt;p>验收测试。需求的沟通细节，过早精细化（通用性较差），迟到的模糊性（无法实践，影响进度）。对完成的定义，有些认为写完代码=完成，有些认为测试通过=完成。如果采用TDD，其实写完代码也就意味着大部分测试已经通过了。&lt;/p>
&lt;p>团队与项目。一个有凝聚力的团队，可能会让你变成120%的那个你。&lt;/p>
&lt;p>如何对时间、压力进行管理。&lt;/p>
&lt;p>这本书，可以在碰到问题时找到相关的章节去看看有没有什么解决方案，不一定有用，至少可以帮助开拓一定的思路。&lt;/p>
&lt;p>相关大佬: Kent Beck; Martin Fowler; R. C. Martin&lt;/p>
- https://akelio-zhang.github.io/posts/2020clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/ - 2019-2022 Akelio All rights reserved.</description></item></channel></rss>