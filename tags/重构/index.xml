<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>重构 on LIFE CODER</title><link>https://akelio-zhang.github.io/tags/%E9%87%8D%E6%9E%84/</link><description>Recent content in 重构 on LIFE CODER</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>2019-2023 Akelio All rights reserved.</copyright><lastBuildDate>Sat, 06 Jun 2020 18:00:00 +0000</lastBuildDate><atom:link href="https://akelio-zhang.github.io/tags/%E9%87%8D%E6%9E%84/index.xml" rel="self" type="application/rss+xml"/><item><title>系统复杂度 Part I</title><link>https://akelio-zhang.github.io/posts/2020-%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/</link><pubDate>Sat, 06 Jun 2020 18:00:00 +0000</pubDate><guid>https://akelio-zhang.github.io/posts/2020-%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/</guid><description>系统复杂度 Part I 关键词 系统复杂度、重构、设计模式、测试
0x1 Introduction 当你接手一个不熟悉的系统的时候，你可能想找一下系统文档（但是已经很久没更新了）；你可能想看一下有没有单元测试（很多根本跑不起来了）；这时候，除了问同事，只能自己从几千几万行代码中开始摸索。
当你开发一个新系统的时候，由于某些原因需要调整局部的逻辑，因为没有相应的单元测试，结果在移交给测试后才发现各种顾此失彼的bug出现了。
当你的系统性能已经无法再满足时，又或者系统的迭代成本异常大时，此时就会可能需要重写或重构。此时，由于没有单元测试，自动化集成测试，你不得不拉上更多的同事来参与此次系统优化，以保证系统的可靠性。
当你的系统需要有新的客户接入时，因为没有最新的系统文档或使用说明书，你只能电话、口头地来教别人怎么接入你的系统。
上述的几个场景，都是因为系统的配套设施（文档、测试）没有同步完善，引起接入、迭代、重构的成本显著增加。这不是我们想看到的。相对地，系统的快速迭代的开发模式已经受到了广泛的认同，我们怎么在这个过程能够一直保持高效、可靠的输出呢？对于这个问题，本文尝试从系统复杂度、重构、设计模式、测试这几个角度来讨论这个问题，希望能给大家一些新的思考。
插曲，在招联面试中，关于软件工程回答中，我的答案是说，它与结构工程一样，都需要在有限的资源条件下，用尽可能优化的设计，来实现降低成本地完成目标。经过了近2年的打磨，我对这个问题有了更多的理解。迭代，变化性，设计依据。
0x2 系统复杂度 首先，算法有复杂度一说，在所有的算法课程基本都会在前1-2章围绕这个话题展开详细的定义与分析讨论。算法复杂度一般分为时间复杂度与空间复杂度，可以说是该算法解决问题的时间与空间成本。
在工作上，我们维护的往往是一个系统，一个工程。一个系统的复杂度定义，似乎并不是那么容易。本章节大多数内容来源于_A Philosiphy of Software Designing_。这本书中对于系统的复杂度定义非常的实际，软件系统结构中让其变得难以理解且难以变更的部分组成了系统的复杂性。回顾本文引子部分，其实都是系统难以理解、难以修改导致的结果。
这个定义相对于算法复杂度而言，显得非常主观，没有客观的评估准则，各个人的理解也会大相径庭。因此，书中进一步展开了几种复杂性症状。
变化放大(change amplication)：当你需要改动某一个逻辑时，会涉及到多处代码变更。 认知负担(cognitive load)：有时尽管只写了很少的代码，但是对于他人来说异常难以理解，请尝试将它改写成容易理解的方式。 不可知(unknown unknowns)：不知道哪里有坑存在，就算BUG出现了。 总的来说，控制住整个系统的复杂度，将是保障我们高效、可靠工作的核心。低复杂度的系统，大大降低了开发过程中的心智压力。
0x3 测试 为什么要把测试放在靠前的位置呢？测试是将一直伴随在生产代码演进的，是软件的可靠性保证的重要工具。
拿建筑工程做一个类比，设计一幢房屋时，对于设计人员，最终产出的是施工图。那么，它的设计依据是什么呢？《规范》与模型的承载能力分析。前者，描述了什么类型的结构需要怎么样的设计，这种属于基本要求。后者，通过基于物理建模软件进行专门的结构性能分析，来确保本次设计的可靠性。
软件工程相比建筑工程，非常年轻，一方面没有条条框框地规则（P3C也仅仅是一些基础性条约）；另一方面，因为大部分软件工程不涉及生命财产，也可以通过快速更新来解决问题，所以导致大多数人对可靠性的关注度远不如建筑工程。先不说这样的态度容易使生产问题频发，另外也会让你的工作开展体验感相对差劲，总是在返工。
因此，我们需要在注重软件的可靠性。我们的第一个工具就是（自动化）测试。好的测试，就能够有效地模拟真实地业务场景，来校验代码的正确性。好的测试，能够让新加入的开发人员更容易理解系统是如何使用的。好的测试，能够促进系统架构的合理化——高内聚低耦合。但是，好的测试代码并不容易写，因为测试代码的思考方式与一般的coding并不一样，它更像是生产代码的前置条件、运行场景。
测试通常分为四个层次：单元测试（Unit Testing）、集成测试（Integration Testing）、系统测试（System Testing）、验收测试（Acceptance Testing）。其中离开发最近的是单元测试，一般覆盖的是函数以及类的功能正确性。集成测试则是对系统内部的各模块之间的协作是否正确，通常按内部接口进行覆盖测试。系统测试则是验证对外接口能否在各种情况下能够正常地运行（性能测试也属于这一层次）。验收测试属于辅助性的测试，范围也相对更广，不同的系统也会需要不同的验收测试，例如安全测试、易用性测试、兼容性测试等等。
这里我们主要谈一下单元测试，因为这是所有测试的基本面，也是开发人员所需要特别关注的地方。先考虑一下是先写生产代码还是先写测试代码。第一个角度是，当然是先写生产代码了，没有生产代码怎么测试呢？第二个角度是，先写测试代码再写生产代码，因为测试代码是功能的运行场景，只有先把这些前置条件搞清楚了，才能写出正确的生产代码。也许你会说，我可以先大脑过一下基本场景，然后再写生产代码，再写测试代码，这应该是大部分人目前的方式，但是不知道你有没有发现，这种方式写出来的测试代码往往会因为前期的假设导致覆盖率很低。
在2003年，Kent Beck提出了Test-Driven development（TDD）这样一种开发模式。
添加一个测试 运行所有测试，是否有失败 一旦有失败的测试，就开始写生产代码，直到该测试通过为止。 所有测试通过后，就必须开始写测试代码，直到有一个测试无法通过。 可能，你会觉得这样非常耗时，但是你得明确，你在一个功能开发的耗时并不仅仅是写了那一堆生产代码而已，还包括测试、代码修复等等。所以，这种方式只是将一些顺序进行了调换，却能为最终的正确性铺垫很多。
0x4 重构 重构与重写都是试图优化系统复杂度的方式，在不同的场景（代码状况、工期等）会选择不同的方式，但是大多时候会采用重构的方式来实现。
先来看一下wikipedia对重构的定义：
In computer programming and software design, code refactoring is the process of restructuring existing computer code—changing the factoring*—without changing its external behavior.</description></item><item><title>Clean系统读书笔记——两年项目回顾</title><link>https://akelio-zhang.github.io/posts/2020-clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/</link><pubDate>Wed, 27 May 2020 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2020-clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/</guid><description>Clean系统读书笔记——两年项目回顾 0x1 引子 这是一篇在快速浏览了一圈《Clean Code》《Refactoring》《Clean Coder》这三本书之后的读后感。仅作为一篇备忘录。
在很早很早时候，开始准备转CS的时候就知道了Refactoring这本书，当时很简单地扫了一眼，就感觉很多东西都不明所以，要么就觉得，这不是本该就这样吗？于是就一直扔在网盘没再看过。
软件工程 VS 建筑工程
深思，结构设计与IT系统设计，都是一种系统设计，但是结构设计相对来说 约束比较明确，量化也很明确，干嘛的，负载多少，并且建筑设计已经进一步做了一层约束，所以到结构这边，整个外界的条件已经很丰富了，所以针对这个相对来说 应该有比较容易的解答了。相反，在IT系统这边，往往需求开始就是模糊的，体量也是预计的，往往后期会增加，还会有那些“灰色”流量。这些难以量化的约束，使得在整个系统设计上就变得很困难，因为没有万能的系统。并且系统能够承载的东西，往往随着时间会变得越来越丰富，这时候如果早期的设计比较局限，就可能要整体重构等等。在这种宽约束下的系统设计能力，需要好好锻炼。「一次交付和不断迭代的产品」—— by C. Gen
那么，就先从2018年开始回顾。
0x2 2018 Function works! 18年开始工作之后，一开始只是做一些很简单地Feature的增加，大约一个Feature只设计100行代码左右。所以基本就是在1-2个函数可以解决问题，也不太涉及OO方向的变更（采用系统本身的设计即可），所以在18年这个时间点上，主要是在函数层面做工作，各种类也是相对独立地使用，更多关注的是功能正常和简单的单元测试。
除此以外，很多时间是在熟悉团队的各个系统的定义与功能，（如何快速熟悉一个系统）以及各种容器、工具（IDEA、Maven、Tomcat、Dubbo、Vue、Element、CI、Logback、Restful MVC、MyBatis&amp;hellip;）的熟悉了解。
总结来说，2018年在熟悉基本工作外，在不断地打开(broaden)自己的知识网络。
0x3 2019 流程系统，痛点解决，大数据起步 设计文档，流程图，UML，DDD
2019年开始，阴差阳错处于空档期，接了一个项目（当时其实就是很迫切地想做一些大一点的项目，来提升自己的能力，也没有对需求去做直接的评估）。现在回头再看，这个项目属于一个非常偏向业务的功能模块开发（从技术角度并没有太多需要考量的点，流量也是比较小的）。涉及到要开发的点有前端页面，中后台运营平台的开发，后台系统的业务流程（较复杂，场景较多）处理。
当时，基本就和同事定了一下大体的功能点放在哪些模块，以及表结构的设计，就直接开始动手写了。设计文档无，流程图无，这导致后期开发维护都变得很困难，好在是在第三期的时候补充了不少。
相比18年的函数级别的开发，这项目涉及到了多个系统，一条业务请求的多次变更，各种异步处理。要考虑地就更多了：核心类如何设计，每个流程的具体设计（需要由哪些类来支撑），系统与系统之间的交互设计等等（项目中涉及到Redis、MQ、RPC、DB这样四种方式来进行数据交互）。
至此，让我充分意识到设计文档、流程图、UML等图文，对于一个项目的意义有多大了，它们不光指导了当前的开发工作，还为未来的迭代开发节约了大量的时间。
PS. 由于流程复杂，单元测试也基本没怎么做，之后测试BUG较多。带有数据源的单元测试如何做？
基于Mybatis，Jar包统一了多个系统的结果码合并逻辑。
基于Dubbo Cluster SPI优化了规则发布效率。
大数据起步，数据匹配、变量能效评估系统。Scala、Spark、Impala、Hive。
总结来说，2019年在拓展知识（大数据）的同时，发现了自己的系统设计这一块的不足，简单了解了设计文档、UML、流程图、DDD、贫血模型等。此外，还算是比较努力地尝试改善了当前系统中地一些顽固点（职责收拢、提高性能）。
0x3 2020 高流量的实时系统设计 实现细节文档，TDD，类单一职责（只有一个原因发生变更）、减少类之间的知识(class, function and etc.)共享坏味道的嗅觉开发指导
先提一嘴，在2020参与的一些面试中，发现对于Spring这一块的问题已经非常非常少了，问的最多的可能也就是AOP和事务实现这一块了。一方面是可能大家对于Spring这块较为熟悉了，另一方面是Spring在我看来已经越来越不适合目前大流量的场景（相对来说比较臃肿，对分布式这一块的原生支持也比较弱，尽管已经有了Spring Cloud），一些新的框架（如Vert.x、Micronaut等）在分布式这一块是在设计初期就考虑进去的。
同时，在知乎一个问题上的一个问题——Spring是否代表着目前Java技术的顶峰，未来的Java将如何发展？。我觉得这个问题下面有个回答很有意思，php之于Web开发，Spring之于Java是很类似的地位。
总的一句话，不要抱着老的东西不放，但也要取其精华。
2020年，注定是一个非同寻常的一年，今年到现在，主要就在围绕实时计算平台做工作。
2月基本在做关于提高性能的预研工作（目前我们大系统都以同步调用为主，导致在IO这一块会浪费比较多的资源），因此在异步、协程这一块做了比较多的调研工作，这一块到时候可以单独写一篇文章聊一聊这些模型。总的来说异步回调的写法其实比较反人类，callback hell导致可读性急剧下降。协程本质是一种用户级的调度，免去了陷入到OS内核的开销，但是还是存在一定的overhead，所以性能层面讲异步回调还更好一些。另外还有几种针对并发的模型：Actor和CSP，这两个回避了过去共享内存的数据交互方式，采用消息来进行沟通。我感觉这两个更接近面向对象的思维，也贴近真实生活中人与人的协作方式（讲话、邮件）。
3-4月就属于开始编码的阶段，最困难的还是类的设计（包括成员以及实现的函数）。就讲讲返工，以及代码让自己感觉比较geying的几个场景吧。
计算实现的细节，从A-&amp;gt;B-&amp;gt;C，做了三版。A的主要问题是，内存计算与IO线程混用影响整体性能。B，从业务角度考虑，可用性较差。C，当前的实现，为了系统实现上的简化，仍然对业务提出了一些要求，但是目前认为较合理。 对于系统内部全流程都使用的类，建议不要直接使用API包中的类，比较受限制。 操作一个类中的数据，只能使用这个类提供的方法，而不能直接操作成员变量。（例如，getMap().put(key, value)，这种写法会让后期维护成本很大） 不要过早重构（extract method、类的抽象），因为此时很多问题还没有真正暴露。 异常定义也需要写进设计文档。 不要试图复用同一个单元测试，如果要增加测试case，就直接新增。 总的来说，花2个月的时间来实现这个系统（底层代码是基于已有的工程修改），我认为是比较久了。那么，现在回顾想想有哪些方式可以提高效率的。</description></item></channel></rss>