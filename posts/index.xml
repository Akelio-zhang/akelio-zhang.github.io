<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on LIFE CODER</title><link>https://akelio-zhang.github.io/posts/</link><description>Recent content in Posts on LIFE CODER</description><generator>Hugo -- gohugo.io</generator><language>zh</language><copyright>2019-2022 Akelio All rights reserved.</copyright><lastBuildDate>Sun, 19 Mar 2023 18:00:00 +0800</lastBuildDate><atom:link href="https://akelio-zhang.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>我的P.A.R.A实践记录</title><link>https://akelio-zhang.github.io/posts/2023-%E6%88%91%E7%9A%84para%E5%AE%9E%E8%B7%B5/</link><pubDate>Sun, 19 Mar 2023 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2023-%E6%88%91%E7%9A%84para%E5%AE%9E%E8%B7%B5/</guid><description>我的P.A.R.A实践记录 什么是P.A.R.A The P.A.R.A. (Projects, Areas, Resources, Archives) method is a method for organizing digital information.
It was developed by Forte Labs, a company that creates content to help increase productivity through technology.
Project: 短期、长期项目，用于Area的实践落地。 Area: 关注的核心领域与能力提升。 Resource: 用于Area相关联的信息整理以及其他可能感兴趣的内容。 Archive: 另外三项不活跃的内容移入这个地方，减少对活跃项目的干扰。 Practice Data Collection: Cubox Send to Obsidian through &amp;ldquo;自定义动作&amp;rdquo; Information Station and Writing: Obsidian Publish to github.io: A Python script to copy blog files to blog_source Publish to Wechat Official Account: A web converter to make blog files suitable to wechat Knowledge Output: github.</description></item><item><title>软件工程师的能力</title><link>https://akelio-zhang.github.io/posts/2022-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%83%BD%E5%8A%9B/</link><pubDate>Fri, 30 Dec 2022 23:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022-%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%83%BD%E5%8A%9B/</guid><description>网上看到的一则关于软件工程师的能力模型图，觉得非常通俗易懂，拿出来分享。若有版权问题，请联系。
基础 计算机知识体系 软能力&amp;mdash;-沟通/协调/心理/个人管理 业务能力&amp;mdash;-商业、业务降本增效 几个搞定 搞定事情&amp;mdash;-项目管理 搞定代码&amp;mdash;-架构设计与自动化 搞定机器&amp;mdash;-运维与监控（devops） 搞定人员&amp;mdash;-团队建设</description></item><item><title>CS自学 Roadmap</title><link>https://akelio-zhang.github.io/posts/2022-cs%E8%87%AA%E5%AD%A6-roadmap/</link><pubDate>Sun, 26 Jun 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022-cs%E8%87%AA%E5%AD%A6-roadmap/</guid><description>CS自学 Roadmap 这两年收集很多课程，也受到csdiy.wiki的启发，觉得整理一份自己觉得比较合适的roadmap，供大家参考。
Roadmap 快速版 CS61A + CS61B + CS61C 这三个课程都来自于UCB，能让你最快判断自己是否适应CS的内容，并帮助你找到还不错的工作(maybe)。 循序渐进版 入门 （Crash Course Computer Science） 数据基础 微积分/线性代数/信息理论/概率统计/离散数学 基本原理 程序抽象 CS61A 计算机架构入门 （Build a Modern Computer from First Principles: From Nand to Tetris (Project-Centered Course) | Coursera） 15-213/CS61C 数据结构与算法 CS61B/6.006/普林斯顿红宝书 领域基础 通览 6.</description></item><item><title>单元测试减少心智负担</title><link>https://akelio-zhang.github.io/posts/2022-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%87%8F%E5%B0%91%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85/</link><pubDate>Wed, 15 Jun 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E5%87%8F%E5%B0%91%E5%BF%83%E6%99%BA%E8%B4%9F%E6%8B%85/</guid><description>单元测试减少心智负担 责任意识 案例1: 错误的空判断，导致错误放款上百万； 案例2: 使用本地环境打包，部署到线上环境后异常，官网无法访问； 线上问题，第一责任人基本都是软件开发人员，不是测试、也不是运维人员； 什么是单元测试 在计算机编程中，单元测试（英语：Unit Testing）又称为模块测试 ，是针对程序模块（软件设计的最小单位）来进行正确性检验的测试工作。程序单元是应用的最小可测试部件。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。 通常来说，程序员每修改一次程序就会进行最少一次单元测试，在编写程序的过程中前后很可能要进行多次单元测试，以证实程序达到软件规格书要求的工作目标，没有程序错误；虽然单元测试不是必须的，但也不坏，这牵涉到项目管理的政策决定。 每个理想的测试案例独立于其它案例；为测试时隔离模块，经常使用stubs、mock或fake等测试马甲程序。单元测试通常由软件开发人员编写，用于确保他们所写的代码符合软件需求和遵循开发目标。它的实施方式可以是非常手动的（透过纸笔），或者是做成构建自动化的一部分。 为什么要做单元测试 保证功能的正确性； 适应于代码改造、重构； 对功能的一种文档记录（包括一次BUG，对应一个单元测试） 从使用者的角度先行设计（参考——测试驱动开发TDD） 收益 更短的修复时间 更少的开发成本 更高的代码质量 哪些代码要做单元测试 最理想，100%的代码覆盖率以及分支覆盖率。 覆盖率好不等价于代码合格 时间有限 核心功能代码 逻辑复杂的代码 分支较多的代码 数据状态变化较多的代码 怎么做单元测试 从一个Java程序开始 怎么做Spring容器的单元测试？ @SpringBootTest 数据库数据怎么办？ @DbUnit 单元测试的建议 日志或者System.out.println对测试无意义 如依赖数据库，建议使用非测试数据库，并用spring-test-dbunit来做数据初始化准备。 如依赖外部接口，建议有相应的测试接口，保证其接口输入与响应保持一致性 了解一下测试驱动开发，能提高对代码可测试性、模块设计的理解。 参考 单元测试 - 维基百科，自由的百科全书 (wikipedia.</description></item><item><title>读书笔记--用数据讲故事</title><link>https://akelio-zhang.github.io/posts/2022-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AE%B2%E6%95%85%E4%BA%8B/</link><pubDate>Fri, 15 Apr 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AE%B2%E6%95%85%E4%BA%8B/</guid><description>读书笔记&amp;ndash;用数据讲故事 第二章 选择有效的图表 图表类型 简单文本 表格（不利于展示你的观点） 热力图 点图 散点图（往往需要配合辅助线、辅助文本） 线图 折线图（可以增加最大值、最小值的同图展示） 斜率图 条形图 直方图（竖直条形图） 堆叠竖直条形图（一般是最下一层能够比较有效对比） 瀑布图 水平条形图（适合阅读，分类标签可以很长） 面积图 图表使用建议 不要使用饼图 不要使用3D图 尽量不要使用双Y轴 第三章 杂乱是你的敌人 第四章 聚焦受众的视线（引导到核心的数据） 前属性 颜色 大小 第五章 像设计师一样思考（通过可视化，让读者观众明白你的结论，第四章的升级版） 可供性 突出重要内容 消除干扰 无障碍 不要过于复杂 擅长使用文字突出结论 美观 接受度</description></item><item><title>决策引擎 Note</title><link>https://akelio-zhang.github.io/posts/2022-%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E-note/</link><pubDate>Fri, 25 Mar 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022-%E5%86%B3%E7%AD%96%E5%BC%95%E6%93%8E-note/</guid><description>决策引擎 Note 开场 常见的引擎有哪些？ 游戏、模板、规则、决策； 引擎是一套通用的软件解决方案，基于引擎，可以实现一类相似的业务需求； 决策引擎是什么？ 如果用最简单的说，对某一类型的事件进行加工处理后得到一个决策结果； 从这句话看起来，和规则引擎很像，确实很像，或者说决策引擎是一种高级的规则引擎（是基于规则引擎的提升改造以适应更加复杂的流程）； 怎么会自己开发出一个决策引擎 罗列业务上的诉求 时间线 所以一个东西并不是一蹴而就的，也是因为业务的复杂逐渐提升，引擎也在随之提升变化 如何设计 原则 组合&amp;gt;继承 单一责任 每一个类应该和尽可能少的类交互，对象的层次设计 主要对象 Filter TaskNode Task FlowEngine IFlowContext 效果 代码工程可读性、可测试性（可维护性）强； 不同决策模型均适应 易扩展 方便查问题（日志落表与业务逻辑完全解耦） 可以在大数据环境运行（不基于Spring） 应用 同业预警财务模型V2 未来规划 支持并发 支持节点超时配置 前端展示转换层，配置与执行流可视化，便于运维 启示 原型能力 从规则引擎&amp;ndash;&amp;gt;规则引擎V2&amp;ndash;&amp;gt;决策引擎 产品需要打磨 其他</description></item><item><title>LeetCode 刷题指南</title><link>https://akelio-zhang.github.io/posts/2022-leetcode-%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</link><pubDate>Fri, 18 Feb 2022 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022-leetcode-%E5%88%B7%E9%A2%98%E6%8C%87%E5%8D%97/</guid><description>LeetCode 刷题指南 “刷题”的意义 刷题确实可能会让非常多人嗤之以鼻，但是没有办法，这一切都是市场决定的。如果要在这个市场生存，你只有两个选择，适应这条规则或者打破这条规则。如果我们可以打破这条规则，那说明我们拥有更大的价值，这当然很好。但是对于大多数人而言，可能或多或少会得刷一刷题。刷题一方面能让我们面试通过，另一方面也在过程中重温一些基础知识（可以不用再面对繁冗复杂的业务诉求）。
如何刷 笔者自己是从两条线分别出发刷题。一，按数据结构类型；二，按算法策略。从这两条线组织刷题顺序可以帮我们更快地构建起题与知识的映射关系。其实在面试解题过程中，关键要解决的就是破除题目本身的外壳，发现本质问题，属于什么类型的问题，需要用怎么样的数据结构与算法来解决。
现在LeetCode刷题已经非常方便了，并且本身社区也比较活跃。但是，额外的一些参考书籍对于我们的帮助也会非常大。下面罗列两本LeetCode题解。第一本101，是采用C++解题的，这本书的算法写的很容易理解，不像LC社区中很多人追求花哨——一行解题，意义不是很大。在面试过程，清晰的算法过程也是会给面试官比较好的音响。另一本Go写的题解，追求是算法性能，可以给我们拓宽思路，因为一道题解出来现在可能已经不是100分了，最佳的性能会让我们的面试更加突出。
LeetCode 题解参考 Doing positive things. - LeetCode 101 (changgy.com)
序 | LeetCode Cookbook (halfrost.com)
算法参考书 ⭐Algorithms, 4th Edition by Robert Sedgewick and Kevin Wayne (princeton.edu)
The Algorithm Design Manual (algorist.com)
⭐Algorithms by Jeff Erickson (illinois.edu)</description></item><item><title>MacBook Pro到手设置</title><link>https://akelio-zhang.github.io/posts/2022-macbook-pro-%E5%88%B0%E6%89%8B%E8%AE%BE%E7%BD%AE/</link><pubDate>Thu, 10 Feb 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2022-macbook-pro-%E5%88%B0%E6%89%8B%E8%AE%BE%E7%BD%AE/</guid><description>MacBook Pro到手设置 效率 Office 365, Microsoft edge, Onedrive, Todo, Outlook Xmind Cubox Typora Sketch 开发者 Homebrew, https://brew.idayer.com/guide/ Stats Alfred Item2+ayu VS code extension copilot tabnine wakatime Terminal (item2) https://wyydsb.xin/Operations/terminal.html#zsh-sh Zsh-syntax-highlighting Zsh-autosuggestions Fzf with vim plugin vimrc + vim plug tabnine by coc.nvim Java JetBrains IDEA extensions same as vs code. JDK (Java Download | Java 8, Java 11, Java 13 - Linux, Windows &amp;amp; macOS (azul.</description></item><item><title>Notion结束文字工作站的选择纠结</title><link>https://akelio-zhang.github.io/posts/2021-notion/</link><pubDate>Thu, 27 Jan 2022 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2021-notion/</guid><description>0x1 使用过的方案 有道云笔记（markdown支持太弱） Microsoft Todo（不太适合大量文字记载） 语雀（不适合临时想法记录） Typora/VS Code + Onedrive（文件之间的关联比较麻烦，没有统一的入口） 微信公众号（不适合个人内容记载，且使用起来比较麻烦，适合做推广） 0x2 场景整理 问题的解决方案往往要追溯到需求本身，不然只是在为了使用而使用，缺乏了创造力。
工作上对项目、系统的设计、开发、运维的文档落地与持续运维追踪。 读书笔记记录。 CS一些技术的学习笔记。 生活的一些行程安排或记录。 Todo List。 0x3 Notion，最大好处就是ALL IN ONE。 良好的Markdown支持 UI符合我的审美需求 能够支持大量文字输入 因为是web，天生跨平台 block，database，link的设计，能够满足绝大部分的知识库使用场景（场景2-4） 支持项目管理，可部分替代teambition（场景1） 支持Todo，可部分替代todo app（场景5） 有些遗憾 所有数据在线，尽管有了Github的备份和导出，但是没有一套本地持久化的方案总觉得并不安心。 没有标签系统 不支持快速的外部文章导入 0x4 目前的文字工作方式 DASHBOARD是所有内容的入口。 DASHBOARD展示的内容尽可能少，一般就是日常要做的、工作追踪、学习提升的三个入口。 Notion主要做有一些计划性的、需要有结果输出的文字工作。 每天使用Github进行备份 [H1]Todo来承载一些紧急类的工作记录（往往重要性不会太强）【可以用便利贴替代】 [H2]Xmind承担思维脑图，基本无可替代，数据用Onedrive管理。 [H3]备忘录只做个人信息备忘录，待办事项直接用todo/cubox解决。 [IN]cubox承载信息流的记录（手机、PC浏览器），替代之前的微信收藏、知乎收藏。 [OUT]微信公众号、知乎专栏用来做对外输出。（Notion本身也提供了链接分享，但是有墙，并没有什么x用） 放弃语雀，是因为流量还是小了一点。 Onenote暂时处于停止使用的状态，主要原因是格式版本比较心累，markdown不好用，跨平台能力有限。但是对于一些图、画较多的场景，Onenote有他自由排版的优势。 当然，目前在使用Notion还有一些不舒服的地方：1）DASHBOARD呈现的内容过多，会分散注意力；2）Notion中很多已经完成的内容，目前只是简单放在database置为完成状态，或者移入存档Page。这些内容在较长不会做更新，却依旧占据了较多的篇幅，也会分散注意力。目前使用toggle或者database filter来隐藏。</description></item><item><title>About Me</title><link>https://akelio-zhang.github.io/posts/about-me/</link><pubDate>Wed, 26 Jan 2022 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/about-me/</guid><description>绝大多数软件都为生产活动在数字世界的投射。
Coder &amp;amp; Photographer
我的设备 [工作]
Computing Macbook Pro (M1 Pro + 32G), Year 2022 *PC (i7-8700 + 32G + GTX 1066), Year 2020 *NUC 11 (16G) for ESXi (Homelab: win10 + Manjaro), Year 2021 *QNAP T453D mini with (512G + 256G + 4T), Year 2021 *ThinkPad T460s (i7-6600U + 8G), Year 2016 *RaspBerry 3 (for scheduling), Year 2015 Monitor *Dell 2720Q, Year 2020 *Dell 2414H, Year 2015 Dell 2520DR, Year 2020 Keyboard Max Keys *Filco 87 Black Anne Pro II Mouse *GPW G304 Speaker *Bose SoundLink Resolve Lighter *BenQ ScreenBar Halo Xiaomi ScreenBar star(*) for home use [生活]</description></item><item><title>Git指南</title><link>https://akelio-zhang.github.io/posts/2021-git%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 03 Jan 2022 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2021-git%E6%8C%87%E5%8D%97/</guid><description>Git指南 零、目的 掌握各类场景下如何更好使用Git。 减少因为代码提交问题带来的生产环境问题。 一、了解[[Git]] 什么是Git？ 1. 一款分布式版本管理系统 2. 优点：分布式、性能、版本的文件完整性 1. 分布式，可以让你在本地提交代码（对于SVN而言没有网络就无法提交代码，在家也能愉快地写代码）； 2. 性能，对于我们的一般项目而言，你感受不到合并时性能的差别（与SVN比较）； 3. 版本的文件完整性：git背后设计理念是快照思想。 Git概念 1. 仓库(repository) 1. 用于代码版本管理 2. 一个git仓库管理了三棵“树”，分别是 1. Working Directory（工作目录） 2. Index（暂存区） 3. HEAD（本地仓库） 3. 大多数时候你通过编辑器只能对工作目录操作，操作其他两个“树”（区域）必须使用git命令才可以。 2. 分支(branch) 1. 用于并行独立开发，更方便管理不同开发任务的进度 Git常用命令 1. git add 2. git commit 3. git push 4. git pull 5. git branch 6. git switch 7. git restore 二、最常见的一种使用场景 陈主管说他已经开发好了整个架构，需要我去把几个功能实现一下，并提交到dev分支让他方便Review。
基本流程 1. 先从远程服务器把代码拉到本地：git clone http://197.</description></item><item><title>2020社招互联网技术面试总结</title><link>https://akelio-zhang.github.io/posts/2020-%E7%A4%BE%E6%8B%9B%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</link><pubDate>Sun, 28 Mar 2021 18:00:00 +0000</pubDate><guid>https://akelio-zhang.github.io/posts/2020-%E7%A4%BE%E6%8B%9B%E4%BA%92%E8%81%94%E7%BD%91%E6%8A%80%E6%9C%AF%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93/</guid><description>2020社招互联网技术面试总结 准备 用人单位招聘诉求 对于每个用人单位来说，他们有两个诉求：1.招聘到能够立马(尽快)胜任工作并解决业务痛点的人；2.减少用人成本。
往往第二点是和招聘人利益是冲突的，所以我们只能通过第一点来进行突破，也就是大家常说的你要和你的岗位有较高的匹配度。
对于互联网岗位软件工程师来说，我认为有三方面可以讨论匹配度：1.技术理解深度；2.业务场景理解以及抽象转换的能力；3.团队管理能力。
简历完善 简历是面试双方的书面信息，其目的是为了使得面试官对面试者产生好奇心，且协助双方在面试过程更有内容可说。因此，可以从以下几个角度思考简历是否可以进一步优化。简历虽然很重要，但是也没必要说做到尽善尽美，主要原则还是信息准确以及一定的美观。
信息是否罗列明确且无缺失。 可量化的地方尽可能做量化。 个人特色是否体现在简历之上(最好是对工作有贡献的)。 内容是否与目标岗位有比较好的匹配度。 个人状况 在做面试准备之前，先要了解个人的软硬技能方面的状况来发现匹配度上的差异，以做针对性的准备。
对技术的掌握范围较窄，没有形成对一些问题的统一解决方案。（武器库的理解还比较浅） 缺少团队管理的经验。 对业务的理解较浅，没有主动进行抽象转换。 面试准备 在面试中，往往会有以下几块内容的沟通：个人介绍、项目介绍、算法题、系统设计题、专业知识、技术方案、向面试官提问。系统设计题往往出现在后面几轮部门领导的面试，算法、专业知识则通常出现在第一二轮。技术方案则都会有所涉及。
在社招中，大部分公司会更注重你过往的项目经历，且会在项目上挖掘你的专业知识以及难点技术方案。所以这一块需要深入剖析，包括技术方案、业务场景、拥抱变化的能力(高可用、高并发)等常见的互联网应用的问题。
由于近些年计算机大厂竞争愈发激烈，算法题与专业知识也经常单独进行考察。算法题一般就刷LeetCode中等就可以；专业知识包括数据结构、操作系统、网络、你的主语言使用理解等。
对于向面试官提问，有人说很重要，但是我认为这往往是锦上添花的效果。主导你拿到offer的还是前面提到的基本面。这一块通常体现了你对这份工作的向往程度。
贵司一天工作的时间线大概是怎么样的？
印象最深的一次工作内容是什么？
最近加班频繁吗？
最后，一场面试，当你说话的时间占比越大，往往就越有可能顺利通过。
过程 中小厂 中小厂对人的要求很直白，能干活，最好技术栈比较贴合，如果面试者过往接触的业务一致性一样就更好了。笔者经历了杭州的一家互联网券商的面试，整体体验感难度适中，问题也都比较贴合实际开发过程会碰到的问题。这也可能是因为整体技术栈重合度较高的原因。算法题、专业知识、技术方案（并发、消息、缓存、Scala）。没有涉及系统设计。
大厂 国内大厂面试风格分为两派，项目技术方案为主与算法为主。前者主要在于项目这一块会问的非常深入，并随之伴随各类技术方案的讨论，强调实战经验。后者对于社招也要提出相当的算法与专业知识的要求，以便于进行高效的过滤。
大厂的算法题会结合更实际的场景来出题，而非LeetCode的原题。比如，提供一天登录登出日志文件(time, uid, action)，问如何计算得到在线人数峰值时间点以及90%峰位时间点。
大厂的项目介绍与技术方案往往是大头部分，面试官会从各个角度来测试你工作的含金量与价值。业务问题如何抽象设计、系统如何拆分设计、如何应对未来的大流量、中间件的选择考虑点等。这块可以参考system-design-primer。
外企 外企确实与国内企业差别很大，面试体验感很不错，你会感觉到你被认真对待。往往会在1天完成所有的面试。面试轮次会在3-4次。笔者面试的岗位更偏向于业务部门，所有问题都围绕实际场景展开。比如，算法题是设计一个类，提供两个操作：记录当前系统的负载和返回近5分钟的平均负载。另一个是设计一个命令行工具，实现对参数的读取与处理。
外企社招时对员工的要求普遍较高，并非单靠刷题就可以。比如在系统题中会考察如何进行项目管理，如何测试，如何运维等等非常全面的问题。另一方面，由于外企的产品往往面向全球，会有诸如如何解决多地数据中心同步的问题、攻击网关设计等国际化的问题。
结论 在面试的准备与进行过程中，是对我们自己过往的一次总结与提升。面试失败也不必过于难过，不是每个面试官都是那么专业，也可能是你与这家公司这个岗位目前仍然不那么契合。
每一个人有每一个人的特色与优劣势，每一家公司有每一家公司的喜好。我们能做的就是保持自信，扬长避短，以一种积极友善的态度把握整个面试过程的主动性（比如有些面试官说让你简单说说xxx，此时若是你擅长的，你应该抓住机会表现出你的特色）
站在巨人的肩膀上 校招面试不完全指南 怎样花两年时间去面试一个人</description></item><item><title>系统复杂度 Part I</title><link>https://akelio-zhang.github.io/posts/2020-%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/</link><pubDate>Sat, 06 Jun 2020 18:00:00 +0000</pubDate><guid>https://akelio-zhang.github.io/posts/2020-%E7%B3%BB%E7%BB%9F%E5%A4%8D%E6%9D%82%E5%BA%A6-1/</guid><description>系统复杂度 Part I 关键词 系统复杂度、重构、设计模式、测试
0x1 Introduction 当你接手一个不熟悉的系统的时候，你可能想找一下系统文档（但是已经很久没更新了）；你可能想看一下有没有单元测试（很多根本跑不起来了）；这时候，除了问同事，只能自己从几千几万行代码中开始摸索。
当你开发一个新系统的时候，由于某些原因需要调整局部的逻辑，因为没有相应的单元测试，结果在移交给测试后才发现各种顾此失彼的bug出现了。
当你的系统性能已经无法再满足时，又或者系统的迭代成本异常大时，此时就会可能需要重写或重构。此时，由于没有单元测试，自动化集成测试，你不得不拉上更多的同事来参与此次系统优化，以保证系统的可靠性。
当你的系统需要有新的客户接入时，因为没有最新的系统文档或使用说明书，你只能电话、口头地来教别人怎么接入你的系统。
上述的几个场景，都是因为系统的配套设施（文档、测试）没有同步完善，引起接入、迭代、重构的成本显著增加。这不是我们想看到的。相对地，系统的快速迭代的开发模式已经受到了广泛的认同，我们怎么在这个过程能够一直保持高效、可靠的输出呢？对于这个问题，本文尝试从系统复杂度、重构、设计模式、测试这几个角度来讨论这个问题，希望能给大家一些新的思考。
插曲，在招联面试中，关于软件工程回答中，我的答案是说，它与结构工程一样，都需要在有限的资源条件下，用尽可能优化的设计，来实现降低成本地完成目标。经过了近2年的打磨，我对这个问题有了更多的理解。迭代，变化性，设计依据。
0x2 系统复杂度 首先，算法有复杂度一说，在所有的算法课程基本都会在前1-2章围绕这个话题展开详细的定义与分析讨论。算法复杂度一般分为时间复杂度与空间复杂度，可以说是该算法解决问题的时间与空间成本。
在工作上，我们维护的往往是一个系统，一个工程。一个系统的复杂度定义，似乎并不是那么容易。本章节大多数内容来源于_A Philosiphy of Software Designing_。这本书中对于系统的复杂度定义非常的实际，软件系统结构中让其变得难以理解且难以变更的部分组成了系统的复杂性。回顾本文引子部分，其实都是系统难以理解、难以修改导致的结果。
这个定义相对于算法复杂度而言，显得非常主观，没有客观的评估准则，各个人的理解也会大相径庭。因此，书中进一步展开了几种复杂性症状。
变化放大(change amplication)：当你需要改动某一个逻辑时，会涉及到多处代码变更。 认知负担(cognitive load)：有时尽管只写了很少的代码，但是对于他人来说异常难以理解，请尝试将它改写成容易理解的方式。 不可知(unknown unknowns)：不知道哪里有坑存在，就算BUG出现了。 总的来说，控制住整个系统的复杂度，将是保障我们高效、可靠工作的核心。低复杂度的系统，大大降低了开发过程中的心智压力。
0x3 测试 为什么要把测试放在靠前的位置呢？测试是将一直伴随在生产代码演进的，是软件的可靠性保证的重要工具。
拿建筑工程做一个类比，设计一幢房屋时，对于设计人员，最终产出的是施工图。那么，它的设计依据是什么呢？《规范》与模型的承载能力分析。前者，描述了什么类型的结构需要怎么样的设计，这种属于基本要求。后者，通过基于物理建模软件进行专门的结构性能分析，来确保本次设计的可靠性。
软件工程相比建筑工程，非常年轻，一方面没有条条框框地规则（P3C也仅仅是一些基础性条约）；另一方面，因为大部分软件工程不涉及生命财产，也可以通过快速更新来解决问题，所以导致大多数人对可靠性的关注度远不如建筑工程。先不说这样的态度容易使生产问题频发，另外也会让你的工作开展体验感相对差劲，总是在返工。
因此，我们需要在注重软件的可靠性。我们的第一个工具就是（自动化）测试。好的测试，就能够有效地模拟真实地业务场景，来校验代码的正确性。好的测试，能够让新加入的开发人员更容易理解系统是如何使用的。好的测试，能够促进系统架构的合理化——高内聚低耦合。但是，好的测试代码并不容易写，因为测试代码的思考方式与一般的coding并不一样，它更像是生产代码的前置条件、运行场景。
测试通常分为四个层次：单元测试（Unit Testing）、集成测试（Integration Testing）、系统测试（System Testing）、验收测试（Acceptance Testing）。其中离开发最近的是单元测试，一般覆盖的是函数以及类的功能正确性。集成测试则是对系统内部的各模块之间的协作是否正确，通常按内部接口进行覆盖测试。系统测试则是验证对外接口能否在各种情况下能够正常地运行（性能测试也属于这一层次）。验收测试属于辅助性的测试，范围也相对更广，不同的系统也会需要不同的验收测试，例如安全测试、易用性测试、兼容性测试等等。
这里我们主要谈一下单元测试，因为这是所有测试的基本面，也是开发人员所需要特别关注的地方。先考虑一下是先写生产代码还是先写测试代码。第一个角度是，当然是先写生产代码了，没有生产代码怎么测试呢？第二个角度是，先写测试代码再写生产代码，因为测试代码是功能的运行场景，只有先把这些前置条件搞清楚了，才能写出正确的生产代码。也许你会说，我可以先大脑过一下基本场景，然后再写生产代码，再写测试代码，这应该是大部分人目前的方式，但是不知道你有没有发现，这种方式写出来的测试代码往往会因为前期的假设导致覆盖率很低。
在2003年，Kent Beck提出了Test-Driven development（TDD）这样一种开发模式。
添加一个测试 运行所有测试，是否有失败 一旦有失败的测试，就开始写生产代码，直到该测试通过为止。 所有测试通过后，就必须开始写测试代码，直到有一个测试无法通过。 可能，你会觉得这样非常耗时，但是你得明确，你在一个功能开发的耗时并不仅仅是写了那一堆生产代码而已，还包括测试、代码修复等等。所以，这种方式只是将一些顺序进行了调换，却能为最终的正确性铺垫很多。
0x4 重构 重构与重写都是试图优化系统复杂度的方式，在不同的场景（代码状况、工期等）会选择不同的方式，但是大多时候会采用重构的方式来实现。
先来看一下wikipedia对重构的定义：
In computer programming and software design, code refactoring is the process of restructuring existing computer code—changing the factoring*—without changing its external behavior.</description></item><item><title>Clean系统读书笔记——两年项目回顾</title><link>https://akelio-zhang.github.io/posts/2020-clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/</link><pubDate>Wed, 27 May 2020 12:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2020-clean%E7%B3%BB%E7%BB%9F%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%E4%B8%A4%E5%B9%B4%E9%A1%B9%E7%9B%AE%E5%9B%9E%E9%A1%BE/</guid><description>Clean系统读书笔记——两年项目回顾 0x1 引子 这是一篇在快速浏览了一圈《Clean Code》《Refactoring》《Clean Coder》这三本书之后的读后感。仅作为一篇备忘录。
在很早很早时候，开始准备转CS的时候就知道了Refactoring这本书，当时很简单地扫了一眼，就感觉很多东西都不明所以，要么就觉得，这不是本该就这样吗？于是就一直扔在网盘没再看过。
软件工程 VS 建筑工程
深思，结构设计与IT系统设计，都是一种系统设计，但是结构设计相对来说 约束比较明确，量化也很明确，干嘛的，负载多少，并且建筑设计已经进一步做了一层约束，所以到结构这边，整个外界的条件已经很丰富了，所以针对这个相对来说 应该有比较容易的解答了。相反，在IT系统这边，往往需求开始就是模糊的，体量也是预计的，往往后期会增加，还会有那些“灰色”流量。这些难以量化的约束，使得在整个系统设计上就变得很困难，因为没有万能的系统。并且系统能够承载的东西，往往随着时间会变得越来越丰富，这时候如果早期的设计比较局限，就可能要整体重构等等。在这种宽约束下的系统设计能力，需要好好锻炼。「一次交付和不断迭代的产品」—— by C. Gen
那么，就先从2018年开始回顾。
0x2 2018 Function works! 18年开始工作之后，一开始只是做一些很简单地Feature的增加，大约一个Feature只设计100行代码左右。所以基本就是在1-2个函数可以解决问题，也不太涉及OO方向的变更（采用系统本身的设计即可），所以在18年这个时间点上，主要是在函数层面做工作，各种类也是相对独立地使用，更多关注的是功能正常和简单的单元测试。
除此以外，很多时间是在熟悉团队的各个系统的定义与功能，（如何快速熟悉一个系统）以及各种容器、工具（IDEA、Maven、Tomcat、Dubbo、Vue、Element、CI、Logback、Restful MVC、MyBatis&amp;hellip;）的熟悉了解。
总结来说，2018年在熟悉基本工作外，在不断地打开(broaden)自己的知识网络。
0x3 2019 流程系统，痛点解决，大数据起步 设计文档，流程图，UML，DDD
2019年开始，阴差阳错处于空档期，接了一个项目（当时其实就是很迫切地想做一些大一点的项目，来提升自己的能力，也没有对需求去做直接的评估）。现在回头再看，这个项目属于一个非常偏向业务的功能模块开发（从技术角度并没有太多需要考量的点，流量也是比较小的）。涉及到要开发的点有前端页面，中后台运营平台的开发，后台系统的业务流程（较复杂，场景较多）处理。
当时，基本就和同事定了一下大体的功能点放在哪些模块，以及表结构的设计，就直接开始动手写了。设计文档无，流程图无，这导致后期开发维护都变得很困难，好在是在第三期的时候补充了不少。
相比18年的函数级别的开发，这项目涉及到了多个系统，一条业务请求的多次变更，各种异步处理。要考虑地就更多了：核心类如何设计，每个流程的具体设计（需要由哪些类来支撑），系统与系统之间的交互设计等等（项目中涉及到Redis、MQ、RPC、DB这样四种方式来进行数据交互）。
至此，让我充分意识到设计文档、流程图、UML等图文，对于一个项目的意义有多大了，它们不光指导了当前的开发工作，还为未来的迭代开发节约了大量的时间。
PS. 由于流程复杂，单元测试也基本没怎么做，之后测试BUG较多。带有数据源的单元测试如何做？
基于Mybatis，Jar包统一了多个系统的结果码合并逻辑。
基于Dubbo Cluster SPI优化了规则发布效率。
大数据起步，数据匹配、变量能效评估系统。Scala、Spark、Impala、Hive。
总结来说，2019年在拓展知识（大数据）的同时，发现了自己的系统设计这一块的不足，简单了解了设计文档、UML、流程图、DDD、贫血模型等。此外，还算是比较努力地尝试改善了当前系统中地一些顽固点（职责收拢、提高性能）。
0x3 2020 高流量的实时系统设计 实现细节文档，TDD，类单一职责（只有一个原因发生变更）、减少类之间的知识(class, function and etc.)共享坏味道的嗅觉开发指导
先提一嘴，在2020参与的一些面试中，发现对于Spring这一块的问题已经非常非常少了，问的最多的可能也就是AOP和事务实现这一块了。一方面是可能大家对于Spring这块较为熟悉了，另一方面是Spring在我看来已经越来越不适合目前大流量的场景（相对来说比较臃肿，对分布式这一块的原生支持也比较弱，尽管已经有了Spring Cloud），一些新的框架（如Vert.x、Micronaut等）在分布式这一块是在设计初期就考虑进去的。
同时，在知乎一个问题上的一个问题——Spring是否代表着目前Java技术的顶峰，未来的Java将如何发展？。我觉得这个问题下面有个回答很有意思，php之于Web开发，Spring之于Java是很类似的地位。
总的一句话，不要抱着老的东西不放，但也要取其精华。
2020年，注定是一个非同寻常的一年，今年到现在，主要就在围绕实时计算平台做工作。
2月基本在做关于提高性能的预研工作（目前我们大系统都以同步调用为主，导致在IO这一块会浪费比较多的资源），因此在异步、协程这一块做了比较多的调研工作，这一块到时候可以单独写一篇文章聊一聊这些模型。总的来说异步回调的写法其实比较反人类，callback hell导致可读性急剧下降。协程本质是一种用户级的调度，免去了陷入到OS内核的开销，但是还是存在一定的overhead，所以性能层面讲异步回调还更好一些。另外还有几种针对并发的模型：Actor和CSP，这两个回避了过去共享内存的数据交互方式，采用消息来进行沟通。我感觉这两个更接近面向对象的思维，也贴近真实生活中人与人的协作方式（讲话、邮件）。
3-4月就属于开始编码的阶段，最困难的还是类的设计（包括成员以及实现的函数）。就讲讲返工，以及代码让自己感觉比较geying的几个场景吧。
计算实现的细节，从A-&amp;gt;B-&amp;gt;C，做了三版。A的主要问题是，内存计算与IO线程混用影响整体性能。B，从业务角度考虑，可用性较差。C，当前的实现，为了系统实现上的简化，仍然对业务提出了一些要求，但是目前认为较合理。 对于系统内部全流程都使用的类，建议不要直接使用API包中的类，比较受限制。 操作一个类中的数据，只能使用这个类提供的方法，而不能直接操作成员变量。（例如，getMap().put(key, value)，这种写法会让后期维护成本很大） 不要过早重构（extract method、类的抽象），因为此时很多问题还没有真正暴露。 异常定义也需要写进设计文档。 不要试图复用同一个单元测试，如果要增加测试case，就直接新增。 总的来说，花2个月的时间来实现这个系统（底层代码是基于已有的工程修改），我认为是比较久了。那么，现在回顾想想有哪些方式可以提高效率的。</description></item><item><title>Java传值方式讨论</title><link>https://akelio-zhang.github.io/posts/2019-java%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/</link><pubDate>Sun, 27 Oct 2019 18:00:00 +0800</pubDate><guid>https://akelio-zhang.github.io/posts/2019-java%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E7%9A%84%E8%AE%A8%E8%AE%BA/</guid><description>起因是一次华为面试题
Java在进行函数调用时，参数时传值还是传引用？
当时，我考虑的是Java变量只有两类，基本类型与引用类型，引用类型本质应该是属于指针。所以基本类型与引用类型的实参传递都是值本身，即创建一个副本赋予形参。面试官给的仅仅是笑而不语……
而后在工作了一段时间回想这个问题并没有那么简单。
碰到问题首先要给好定义才能进一步做分析。通过Wiki上关于Evaluation strategy的介绍，其中本文主要关注的这三种方式：call by value, call by reference and call by sharing。
call by value即按值传参，将实参创建一个新副本赋予形参，供函数使用，并且函数对参数的操作，对caller而言是不可见的，即immutable。 call by reference即传引用，函数中的参数就是对实参的直接引用，而不再是一份拷贝（也可以理解成是对实参的一个常量指针），因此是mutable的。 call by sharing，认为该编程语言中所有值都基于对象而非原始类型。在传参过程中赋予形参的是引用的拷贝。因为是引用的拷贝，所以函数体内只能对原对象进行操作，但是不能修改实参引用本身。所以对对象而言，这种传参方式是mutable的，但是对于引用本身，又是immutable的。 现在回头来看下C，C++和Java。
C语言中策略很简单，一切均位call by value，尽管它有指针变量，但是它也是传的实参的拷贝。
C++中出现了引用类型的变量，并且传参时也可以指定call by reference。如，void func(int&amp;amp; n)
Java当中考虑到指针的复杂性，于是直接砍掉了指针变量，只剩下了基本变量与引用变量，另外也不允许选择不同的传参方式。首先看基本变量，比较简单，就是call by value的表现。其次，对于引用变量而言，我们在函数可以对引用的对象进行操作，并且对caller是可见的，但是无法让实参引用到一个新的对象上去，即我们无法在函数中对实参进行assignment相关的操作，即引用本身是immutable的。这就是call by sharing。
这里附上知乎一位答主的回答：
综上所述，对于Java的函数调用方式最准确的描述是：参数藉由值传递方式，传递的值是个引用。（句中两个“值”不是一个意思，第一个值是evaluation result，第二个值是value content）
由于这个描述太绕，而且在字面上与Java总是传引用的事实冲突。于是对于Java，Python、Ruby、JavaScript等语言使用的这种求值策略，起了一个更贴切名字，叫Call by sharing。这个名字诞生于40年前。
作者：Yolanda
链接：https://www.zhihu.com/question/31203609/answer/112157038
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
参考文献：
https://en.wikipedia.org/wiki/Evaluation_strategy https://en.wikipedia.org/wiki/Reference_(computer_science)</description></item></channel></rss>